---
title: "正则表达式"
date: 2024-06-26
tags: ["Regular Expression"]
categories: ["Daily Dev"]
author: "Kurong"
showToc: true
TocOpen: true
draft: false
hidemeta: false
comments: false
disableHLJS: false # to disable highlightjs
disableShare: true
disableHLJS: false
hideSummary: false
searchHidden: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowRssButtonInSectionTermList: true
UseHugoToc: true
searchHidden: false
---

## 第二章. 匹配单个字符

- ' . ' 用来匹配任意单一字符, 元字符的一种

- ' \ '为转义字符, 属于元字符的一种, 元字符: 有特殊含义的字符

- 正则表达式被称为模式(pattern)



## 第三章. 匹配一组字符

- ' [ ] '为元字符, 表示一个字符集合, 必须匹配其中的一个或多个字符, 也可以全部匹配. ' [ ] '可以用来匹配大小写, 如[Aa].*就匹配任意以A或a或Aa开头的字符串. 还有几种常见的用法, 如[a-z] [A-Z] [0-9], 这几种很常用, 还有一个用法[A-Za-z0-9] 这个字符集可以匹配以上三种用法的合集

- ' - '表示连字符, 是一种较为特殊的元字符, 只有在' [ ] ' 里才是元字符, 在其他地方就是一个普通的字符' - ', 也因此在这种情况下它不需要转义

- ' ^ ' 表示排除, 也是元字符. 在上面的几种用法中, 在集合的最前面加上' ^ ', 就表示匹配除了该集合以外的字符, 而且需要注意的是, ' ^ '的作用域是整个字符集合, 而不是紧跟在其身后的单个字符什么的

  

## 第四章. 使用元字符

- 如果要匹配元字符本身, 可以用 ' \ . 如: 匹配[ ], 用\ [ \ ] 

- 匹配空白字符: \n换行符 \r回车符 \t制表符.  如 \r\n 就是匹配一个回车符和一个换行符, 通常被看作一段文本结束的标记

- 一些常用的字符合集可以用特殊元字符代替, 这一类元字符称为类元字符

- 数字类元字符: \d匹配任意一个数字, \D相当于\d的补集, 即匹配任意一个非数字字符

- 字母数字类元字符: \w 匹配任意一个字母(大小写均可)或数字, 或是一个下划线. \W 则是\w的补集, 匹配任意一个非数字字母和下划线的字符

- 空白字符类元字符: \s 任意一个空白字符. \S 任意一个非空白字符

  

## 第五章. 重复匹配

- ' + ' 匹配至少一个或多个字符, 如a+匹配一个或多个a, \d+匹配一个或多个数字

- 字符集合是可以自己创作的, 多种多样的字符集合天下无敌, 如[\w,.':;] 就匹配\w和逗号句号分号冒号单引号

- ' * ' 匹配零个或多个字符, 用法几乎与' + ' 一致

- ' ? ' 匹配零个或一个字符, 用法和上面的两种基本一致

- 以上三个都是元字符

- { }中加上数字就表示匹配前一个字符或字符集合数次, 如 \w{6} 表示匹配\w 6次

- { }可以设置匹配次数的区间, 如{2, 4}匹配至少两次, 最多四次, {2,}表示匹配两次或多次(注意, 逗号后不要加空格)

- ' + ' , ' * ' , {number, }为贪婪型元字符, 与之对应的是懒惰型元字符' *? ', ' +? ', {number, }?  懒惰型元字符只匹配最近的一个, 并只返回一个结果. 要特别注意这两种元字符的适用情形

  

## 第六章. 位置匹配

- 边界: 用于指定模式前后位置(边界)的特殊元字符

- 第一种边界: \b ,是单词边界, 用来匹配一个单词的开头或结尾, 如: \bcat\b匹配cat这个单词 ,\bcat匹配以cat为开头的单词(并不是整个单词, 而是这个单词开头的cat, 下面的例子同理), cat\b匹配以cat为结尾的单词.  如果不想匹配单词边界(即前后没有字母), 可以用\B. 如 匹配一个前后没有单词边界的连字符(-), 用\B-\B 来匹配

- 另外两种边界元字符是: ' ^ ' ,' $'. 分别代表字符串的开头, 字符串的末尾. 这两种是字符串边界元字符.  ' ^ '从字符串的最开始一行匹配.      

- ' $ '从字符串的最末尾一行匹配 

- (?m) 为多行模式, 其迫使正则表达式引擎将换行符视为字符串分隔符. 这样^可以真正意义上从开头开始匹配, 并匹配多行, $也是一样的道理.但是, 注意, JavaScript不支持多行模式

  

## 第七章. 使用子表达式

- 子表达式是更长的表达式的一部分, 划分子表达式的目的是为了将其视作单一的实体来使用.子表达式必须出现在( )里
- 如 匹配html里的空格'& nbsp; ', 用& nbsp;*不行, 因为 *匹配的是' ; '. 必须这样写(& nbsp;) *才行.
- ' | '表示或. 如(19|20)\d{2}表示匹配以19为开头的年份或是以20为开头的年份.
- 子表达式的嵌套, 拿IP地址举例, IP地址由四个字节构成, 所以每组数字的范围都是0-255, 所以IP地址中的每组数字都不能大于255. 每一组有以下四种情况: 1) 任意的一位数或两位数 2) 任意的以1开头的三位数 3) 任意以2开头的, 第二位数在0-4之间的三位数 4) 任意以25开头的, 第三位数在0-5之间的三位数. 若要匹配所有情况, 就必须用到子表达式的嵌套. 完整形式如下: "  (((1\d{2})|(\d{1,2})|(2[0-4]\d)|(25[0-5])).){3}((1\d{2})|(\d{1,2})|(2[0-4]\d)|(25[0-5]))   "   理解起来的意思无外乎以上四种情况
- 理解一个吓人的嵌套表达式(就像上面那个), 由内向外解读更佳, 更易理解



## 第八章. 反向引用

- 反向引用的概念太抽象不好理解, 就直接拿例子说事: [ ]+(\w+)[ ]+\1, 这里的[ ]+匹配一个或多个空格, (\w+)不解释, \1代表引用第一个子表达式, 说白了就是拿过来直接用. 还有\2, \3 分别为引用第二个子表达式.........以此类推.  如: 匹配重复的两个单词 are are, 就直接用[ ]+(\w+)[ ]+\1匹配即可. (注意: 反向引用只能引用在括号里的子表达式)
- 反向引用在替换上的应用, 直接上例子: 这是一个匹配邮箱地址的模式(\w+[\w\.]*@[\w\.]+\.\w+),         这是一个替换模式 href=$1. 
- $1表示对第一个子表达式的引用, 即href= (\w+[\w\.]*@[\w\.]+\.\w+), 这样就可以用来替换文本了.   替换文本的步骤是, 先匹配再替换



## 第九章. 环视

- 举一个例子来说明环视的用处. 你需要从一对标签中提取出文本内容, 直接用正则可以匹配出标签和里面的内容, 但我们需要的是文本而不是标签, 方法之一是用子表达式将正则分为三部分, 再用反向引用来进行引用. 但是这样做过于多余, 我们只想一次性匹配出文本内容, 去除掉无关内容, 这个时候就需要用到环视. 
- 环视分向前看和向后看. ?=表示向前看, 如: 想匹配http://www.baidu.com里的协议, 可以这样写.+(?=:), 这样就可以匹配 'http' 了. ?=:的意思是匹配到: 并从: 开始向前匹配而不匹配: 本身.
- ?<=表示向后看, 即向.....之后查看, 以此方便记忆. 使用方法和注意事项与向前看一样
- 向前看和向后看能够结合在一起使用, 同时以上两种方式称为肯定式向前看, 肯定式向后看
- 与肯定式对应的就是否定式环视. 否定式向前看: ?!,  否定式向后看: ?<! . 否定式向前看只匹配不在该字符前面的字符或字符串, 否定式向后看只匹配不在该字符后面的字符或字符串. 而至于该字符本身不进行匹配.



## 第十章. 嵌入式条件

- 正则表达式的条件要用? 来定义. 如: 字符?, ?=, ?<=等等

- 比较简单的条件不说. 现在说两种条件, 反向引用条件和环视条件.

- 反向引用条件. 例子: 

  123-456-8790
  (123) 456-7890
  (123)-456-7890
  1234567890
  123 456 7890要一次性匹配全部, 可以这样写 \ (?\d{3}\ )?(-?)(\s?)\d{3}?(\1)?(\2)\d{4}, 其中?(\1)和?(\2)就是反向引用条件, 即如果该子表达式存在就引用, 否则不进行引用. 其实就相当与if条件判断. 所以, 还有一种else条件句. (? (backreference) true|false)(不知道为什么总是出错)

- 环视条件. 例子:

  11111
  22222
  33333-
  44444-4444匹配除了33333-的全部, 可以这样写: \d{5}(?(?=-)-\d{4}).  在(?(?=-)-\d{4})这一部分中, 先对?=-进行匹配, 如果匹配到了-, 就执行后面的模式.

匹配中文：[\u4e00-\u9fa5]