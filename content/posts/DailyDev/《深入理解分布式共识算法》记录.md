---
title: "《深入理解分布式共识算法》记录"
date: 2025-03-07
aliases: ["/Daily Dev"]
tags: ["Paxos", "Raft", "ZAB"]
categories: ["Daily Dev"]
author: "Kurong"
showToc: true
TocOpen: true
draft: false
hidemeta: false
comments: false
description: ""
disableHLJS: false # to disable highlightjs
disableShare: true
disableHLJS: false
hideSummary: false
searchHidden: false
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowRssButtonInSectionTermList: true
UseHugoToc: true
---

# 《深入理解分布式共识算法》记录

## 从 ACID 和 BASE 到 CAP

### BASE 理论

BASE 包含；

- BA（Basically Available）：基本可用，当分布式系统出现故障的时候，允许损失部分可用性。这里损失指响应时间的损失和功能上降级，前者是在增加响应时间上来提供服务，后者是在高峰期不请求后端而直接返回降级数据、以保证系统的稳定性。
- S（Soft State）：软状态，允许系统中的数据存在中间状态，并认为该状态不会影响系统的整体可用性，即允许节点之间的数据同步存在延迟。
- E（Eventually Consistent）：最终一致性。

为应用 BASE 理论，可以采用异步补偿机制。如果用这个机制，需要明确哪些操作属于非关键操作，如果非关键操作失败，应允许业务流程继续执行，然后在异步补偿非关键操作。

> 补偿指事务补偿：在分布式事务中，由于各个服务可能分布在不同的节点上，无法像单机事务那样简单地通过“回滚”来撤销操作。因此，事务补偿通过执行与原始操作相反的操作来达到类似的效果。
>
> 补偿操作需要注意两点：
>
> - 幂等性：补偿操作可能需要多次执行，因此需要保证其幂等性，即多次执行的效果与一次执行相同。
> - 最终一致性：补偿机制通常用于实现最终一致性，而不是强一致性，因此需要权衡一致性和性能。

### CAP 理论

CAP 包含：

- C（Consistency）一致性：分布式系统的全序线性一致性。
- A（Availability）可用性：任何情况都能够处理客户端的每个请求。
- P（Partition Tolerance）分区容错性：发生网络分区时，系统仍能提供服务。

任何分布式系统都可分为三类架构：

- CP（锁定事务资源）：所有节点的数据需要实时保持一致性，这需要锁定各分支事务的资源。当发生分区时，此期间为确保返回客户端数据的准确性且不破坏一致性，可能会因为无法响应最新数据而拒绝响应，即放弃 A 。
- AP（尽力提供服务）：要求每个节点拥有集群的所有能力或数据，能独立处理客户端的每个请求。发生分区时，可以通过缓存后本地副本来处理请求，以达到可用性，但会出现各节点不一致性，即放弃 C 。
- CA（本地一致性）：在不发生分区时，C、A 正常满足。一旦发生分区，会保证各子分区满足 CA 。

但是网络分区不可避免，CAP 理论就变成了在 C 和 A 中的权衡问题。



## 2PC、3PC，分布式事务的解决方案

### 2PC

2PC 中的字母含义是 P（Participant，参与者），C（Coordinator，协调者）。

2PC 即两阶段提交协议，用于解决分布式事务问题。第一阶段用于各个分支事务的资源锁定，第二阶段用于全局事务的提交或回滚：

- 第一阶段，准备：
  1. 开启全局事务。当协调者收到客户端的请求后，它将各个分支事务需要处理的内容通过 Prepare 请求发送给所有参与者，并询问能否正常处理自己的分支事务，然后等待各个参与者的响应。
  2. 处理分支事务。当参与者收到 Prepare 请求后便锁定事务资源，然后尝试执行，记录 Undo 和 Redo 信息，但不提交分支事务。
  3. 汇报分支事务状态。参与者根据第 2 步执行的结果，向协调者汇报各自的分支事务状态，Yes 表示可以提交，No 表示不能提交。

- 第二阶段，提交/回滚：
  1. 协调者如果收到所有的响应及所有响应都为 Yes ，就发起全局事务提交；如果没有收到全部分响应或响应中有 No，就发起全局事务回滚。
  2. 汇报分支事务状态。参与者处理完成后向协调者汇报分支事务的状态。
  3. 关闭全局事务。协调者收集到全部的反馈后，向客户端返回结果并关闭本次事务。

从 2PC 的特点能看出，它适用于追求强一致性的场景。但是也能发现，2PC 并没有什么容错。以下是其存在的几个缺陷：

- 同步阻塞：当第一阶段完成后，第二阶段需要协调者存在且正常才能进行下去。否则协调者出现故障，就会导致各个参与者锁定的事务资源无法被释放。
- 数据不一致：发生网络分区后，可能导致只有部分参与者接收到了提交请求，结果就是导致各个节点的数据不一致。
- 单点问题和脑裂：单点问题就是单一协调者一旦故障就会导致 2PC 无法进行。脑裂问题就是出现多协调者（多主）时，无法解决共识问题。

### 3PC

3PC 即三阶段提交协议，分为询问、锁定事务资源、提交事务三阶段，并引入了超时机制。但这里的超时机制是为解决同步阻塞问题，当参与者等待协调者的请求超时后，将会执行默认的提交/中断指令。

- 阶段一，询问：
  1. 协调者收到客户端开启事务的请求后，会向所有的参与者发送包含事务内容的询问请求，询问是否可以执行本次事务。
  2. 参与者收到请求后，先检查自身健康（与协调者的连接、自身处理事务能力等）并判断能否执行以及是否会与其他事务冲突。
  3. 根据检查情况，返回 Yes 或 No。
- 阶段二，预提交：
  1. 根据参与者的响应，在一定时间内响应不全（超时等）或是有 No 就终止全局事务，反之向所有参与者发起预提交。
  2. 参与者收到请求后，锁定事务资源，然后尝试执行，记录 Undo 和 Redo 信息，但不提交分支事务。
  3. 汇报分支事务状态。
- 阶段三，提交/回滚：
  1. 根据参与者的响应，在一定时间内响应不全（超时等）或是有 No 就终止全局事务，反之向所有参与者发起全局提交。
  2. 参与者处理完成后向协调者汇报分支事务的状态。
  3. 向客户端返回结果并关闭本次事务。

3PC 增加了一个询问阶段，就降低了事务资源锁定的范围，不会一上来就锁定。同时超时机制也解决了同步阻塞问题。

### Seata

Seata 是解决微服务架构下分布式事务的框架。



## Paxos 

