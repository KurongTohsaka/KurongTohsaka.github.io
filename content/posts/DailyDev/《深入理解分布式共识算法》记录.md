---
title: "《深入理解分布式共识算法》记录"
date: 2025-03-07
aliases: ["/Daily Dev"]
tags: ["Paxos", "Raft"]
categories: ["Daily Dev"]
author: "Kurong"
showToc: true
TocOpen: true
draft: false
hidemeta: false
comments: false
description: ""
disableHLJS: false # to disable highlightjs
disableShare: true
disableHLJS: false
hideSummary: false
searchHidden: false
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowRssButtonInSectionTermList: true
UseHugoToc: true
---

# 《深入理解分布式共识算法》记录

## 从 ACID 和 BASE 到 CAP

### BASE 理论

BASE 包含；

- BA（Basically Available）：基本可用，当分布式系统出现故障的时候，允许损失部分可用性。这里损失指响应时间的损失和功能上降级，前者是在增加响应时间上来提供服务，后者是在高峰期不请求后端而直接返回降级数据、以保证系统的稳定性。
- S（Soft State）：软状态，允许系统中的数据存在中间状态，并认为该状态不会影响系统的整体可用性，即允许节点之间的数据同步存在延迟。
- E（Eventually Consistent）：最终一致性。

为应用 BASE 理论，可以采用异步补偿机制。如果用这个机制，需要明确哪些操作属于非关键操作，如果非关键操作失败，应允许业务流程继续执行，然后在异步补偿非关键操作。

> 补偿指事务补偿：在分布式事务中，由于各个服务可能分布在不同的节点上，无法像单机事务那样简单地通过“回滚”来撤销操作。因此，事务补偿通过执行与原始操作相反的操作来达到类似的效果。
>
> 补偿操作需要注意两点：
>
> - 幂等性：补偿操作可能需要多次执行，因此需要保证其幂等性，即多次执行的效果与一次执行相同。
> - 最终一致性：补偿机制通常用于实现最终一致性，而不是强一致性，因此需要权衡一致性和性能。

### CAP 理论

CAP 包含：

- C（Consistency）一致性：分布式系统的全序线性一致性。
- A（Availability）可用性：任何情况都能够处理客户端的每个请求。
- P（Partition Tolerance）分区容错性：发生网络分区时，系统仍能提供服务。

任何分布式系统都可分为三类架构：

- CP（锁定事务资源）：所有节点的数据需要实时保持一致性，这需要锁定各分支事务的资源。当发生分区时，此期间为确保返回客户端数据的准确性且不破坏一致性，可能会因为无法响应最新数据而拒绝响应，即放弃 A 。
- AP（尽力提供服务）：要求每个节点拥有集群的所有能力或数据，能独立处理客户端的每个请求。发生分区时，可以通过缓存后本地副本来处理请求，以达到可用性，但会出现各节点不一致性，即放弃 C 。
- CA（本地一致性）：在不发生分区时，C、A 正常满足。一旦发生分区，会保证各子分区满足 CA 。

但是网络分区不可避免，CAP 理论就变成了在 C 和 A 中的权衡问题。



## 2PC、3PC，分布式事务的解决方案

### 2PC

2PC 中的字母含义是 P（Participant，参与者），C（Coordinator，协调者）。

2PC 即两阶段提交协议，用于解决分布式事务问题。第一阶段用于各个分支事务的资源锁定，第二阶段用于全局事务的提交或回滚：

- 第一阶段，准备：
  1. 开启全局事务。当协调者收到客户端的请求后，它将各个分支事务需要处理的内容通过 Prepare 请求发送给所有参与者，并询问能否正常处理自己的分支事务，然后等待各个参与者的响应。
  2. 处理分支事务。当参与者收到 Prepare 请求后便锁定事务资源，然后尝试执行，记录 Undo 和 Redo 信息，但不提交分支事务。
  3. 汇报分支事务状态。参与者根据第 2 步执行的结果，向协调者汇报各自的分支事务状态，Yes 表示可以提交，No 表示不能提交。

- 第二阶段，提交/回滚：
  1. 协调者如果收到所有的响应及所有响应都为 Yes ，就发起全局事务提交；如果没有收到全部分响应或响应中有 No，就发起全局事务回滚。
  2. 汇报分支事务状态。参与者处理完成后向协调者汇报分支事务的状态。
  3. 关闭全局事务。协调者收集到全部的反馈后，向客户端返回结果并关闭本次事务。

从 2PC 的特点能看出，它适用于追求强一致性的场景。但是也能发现，2PC 并没有什么容错。以下是其存在的几个缺陷：

- 同步阻塞：当第一阶段完成后，第二阶段需要协调者存在且正常才能进行下去。否则协调者出现故障，就会导致各个参与者锁定的事务资源无法被释放。
- 数据不一致：发生网络分区后，可能导致只有部分参与者接收到了提交请求，结果就是导致各个节点的数据不一致。
- 单点问题和脑裂：单点问题就是单一协调者一旦故障就会导致 2PC 无法进行。脑裂问题就是出现多协调者（多主）时，无法解决共识问题。

### 3PC

3PC 即三阶段提交协议，分为询问、锁定事务资源、提交事务三阶段，并引入了超时机制。但这里的超时机制是为解决同步阻塞问题，当参与者等待协调者的请求超时后，将会执行默认的提交/中断指令。

- 阶段一，询问：
  1. 协调者收到客户端开启事务的请求后，会向所有的参与者发送包含事务内容的询问请求，询问是否可以执行本次事务。
  2. 参与者收到请求后，先检查自身健康（与协调者的连接、自身处理事务能力等）并判断能否执行以及是否会与其他事务冲突。
  3. 根据检查情况，返回 Yes 或 No。
- 阶段二，预提交：
  1. 根据参与者的响应，在一定时间内响应不全（超时等）或是有 No 就终止全局事务，反之向所有参与者发起预提交。
  2. 参与者收到请求后，锁定事务资源，然后尝试执行，记录 Undo 和 Redo 信息，但不提交分支事务。
  3. 汇报分支事务状态。
- 阶段三，提交/回滚：
  1. 根据参与者的响应，在一定时间内响应不全（超时等）或是有 No 就终止全局事务，反之向所有参与者发起全局提交。
  2. 参与者处理完成后向协调者汇报分支事务的状态。
  3. 向客户端返回结果并关闭本次事务。

3PC 增加了一个询问阶段，就降低了事务资源锁定的范围，不会一上来就锁定。同时超时机制也解决了同步阻塞问题。

### Seata

Seata 是解决微服务架构下分布式事务的框架。



## Paxos 

Paxos 算法分为基础的 Basic Paxos 和 经过 Lamport 优化后提出的 Multi Paxos 。下面的算法讲解基于 Basic Paxos 。

### 基本概念

- 状态机（State Machine）：是一种计算机程序或系统的行为模型，它通过描述一系列状态以及在不同状态下的转移条件和动作来描述系统的行为。
- 容错：在系统运行时对故障的容忍程度。
- 共识：在对等的成员集合中，让每个成员都认可某一个值。
- 多数派（Quorum）：在一个集群中超过一半以上的成员组成的集合，即成员个数大于 $N/2+1$ 。多数派的设定可以在保证安全的情况下有效地提高容错性，少数派就是允许出现故障的数量。
- 提案编号：指一个单调递增的整数，它标识着一轮协商，提案协商之前需要生成一个全局唯一的提案编号。
- 提案：由提案编号和提案指令组成的实体。

### 角色分类

- 提议者（Proposer）：是算法的发起者，它驱动协商的进程，相当于会议的主持人。
- 接受者（Accepter）：是提案的决策者，相当于会议的参会人员。
- 学习者（Learning）：不参与提案的发送和决策，只是被动的接受提案选定的结果，相当于普通民众。

### 算法流程

Basic Paxos 算法可分为三个阶段：

- 准备阶段，协商过程的开始：
  - 提议者生成一个提案编号，并向所有接受者发送包含提案编号的**准备请求**。当接受者收到提案后，会根据约定的规则决定是否需要响应**准备请求**：
    - 如果提案编号大于该接受者已经通过的提案中的最大提案编号，则通过**准备请求**，并承诺在当前准备请求的响应中，加上已经批准的**接受请求**的最大编号的提案指令。如果接受者没有批准过任何**接受请求**，返回空。
    - 如果提案编号小于等于该接受者已经通过的提案中的最大提案编号，则拒绝本次**准备请求**，不响应请求。
  - 如果接受者通过了**准备请求**，则对提议者做出以下承诺：
    - 不再通过编号小于等于本次提案的提案编号的**准备请求**。
    - 不再批准编号小于该提案编号的**接受请求**。
    - 如果接受者已经批准过编号小于该提案编号的**接受请求**，则承诺在本次**准备请求**的响应中加入已经批准过的**接受请求**的最大编号的提案指令。如果接受者没有批准过任何**接受请求**，返回空。
- 接受阶段：
  - 提议者收到多数派的响应后，向接受者发送接受请求，此时的接受请求包含提案编号和提案指令。接受者收到接受请求后，做出以下反馈：
    - 如果接受者没有通过编号比**接受请求**的编号还大的**准备请求**，则批准该**接受请求**，并返回已通过的最大编号。
    - 如果接受者已通过编号更大的**准备请求**，则拒绝本次**接受请求**，并返回已通过的最大编号。
  - 如果多数派的接受者批准了该**接受请求**，说明提案已达成共识。反之，需要回到准备阶段重新开始协商。
- 学习阶段，不属于协商阶段，主要作用是将已达成共识的提案交给学习者进行处理，然后执行状态转移操作。如何让学习者知道提案是否已达成共识，这里只介绍这一种最简单的方案，就是进行提议者同步：
  - 协商过程中，只有提案对应的提议者才知道提案是否已达成共识和最终达成共识的真正提案，所以只要有提案达成共识，那么由提议者立即将该提案发送给学习者。

### Multi Paxos，对 Basic Paxos 的优化

  Basic Paxos 需要多轮才能对一个提案达成共识，所以协商效率很低。Lamport 提出了运行一轮就可以使多个值、多个指令达成共识的 Multi Paxos：

- 引入领导者（Leader）角色，只能由领导者发起提案，减少了活锁的概率。
- 在没有提案冲突的情况下，省略准备阶段，由此优化为一阶段。

Multi Paxos 在执行一次准备阶段的任务，获得了多数派接受者的承诺之后，后续连续的提案只需要执行接受阶段的任务即可。因为领导者认为接受者一定会批准自己后续提出的提案。

Multi Paxos 也允许多主的存在，并允许它们同时发起提案，只要每个领导者按照算法约定运行，便不会影响其算法安全性。为什么？

- 在一个接受者承诺了新领导者的提案编号之后，意味着之前对其他领导者承诺的提案编号将失效，之前领导者发起的接受请求自然会被拒绝。

在 Multi-Paxos 中，领导者的选举过程并非通过显式的投票机制完成，而是通过算法本身的特性隐式产生：

- Multi-Paxos 并未设计独立的领导者选举流程，而是通过提案竞争和全局承诺机制自然形成。当某个提议者连续成功提交提案时，其他节点会默认接受其领导地位，暂停自身提案以避免冲突。这一过程类似于“抢占式协调”，而非传统的主节点投票。
- 具体解释就是：若提议者的提案编号持续被多数派接受（未被更高编号打断），则该提议者实质上成为领导者，后续提案可跳过准备阶段直接提交。



## Raft

 

