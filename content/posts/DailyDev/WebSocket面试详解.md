---
title: "WebSocket面试详解"
date: 2025-08-30
aliases: ["/Daily Dev"]
tags: ["WebSocket"]
categories: ["Daily Dev"]
author: "Kurong"
showToc: true
TocOpen: true
draft: false
hidemeta: false
comments: false
description: ""
disableHLJS: false # to disable highlightjs
disableShare: true
disableHLJS: false
hideSummary: false
searchHidden: false
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowRssButtonInSectionTermList: true
UseHugoToc: true
---

## 第一部分：核心概念

### 1.1 什么是 WebSocket？

WebSocket 是一种在单个 TCP 连接上进行**全双工通信**的协议。它诞生于 HTML5，旨在解决浏览器与服务器之间低延迟、实时、双向通信的需求。

- **全双工 (Full-duplex)**：与 HTTP 的“请求-响应”模式不同，WebSocket 连接一旦建立，客户端和服务器双方可以随时主动向对方发送数据，无需等待对方的请求。
- **单个 TCP 连接**：所有通信都在一个 TCP 连接上完成，减少了重复建立和关闭连接的开销。
- **协议标识符**：WebSocket 的 URL 方案是 `ws://`（非加密）和 `wss://`（加密，运行在 TLS 之上）。

### 1.2 为什么需要 WebSocket？(解决了什么问题？)

在 WebSocket 出现之前，为了模拟实时通信，开发者通常采用以下技术，但它们都有明显的缺陷：

1. **轮询 (Polling)**：客户端定时向服务器发送 HTTP 请求，询问是否有新数据。
   - **缺点**：大量无效请求，浪费带宽和服务器资源；数据延迟高，实时性差。
2. **长轮询 (Long Polling)**：客户端发送一个请求，服务器“挂起”这个连接，直到有新数据时才返回响应。客户端处理完响应后，立即发送下一个请求。
   - **缺点**：仍然有连接开销；服务器长时间持有连接会消耗资源；实现相对复杂。
3. **服务器发送事件 (Server-Sent Events, SSE)**：一种允许服务器向客户端单向推送数据的技术。
   - **缺点**：只能实现服务器到客户端的单向通信，客户端无法向服务器发送数据（除非通过另一个 HTTP 请求）。

**WebSocket 解决的核心问题**：提供了一种**低开销、低延迟、真正意义上的双向实时通信**方案，完美适用于即时通讯、在线游戏、实时数据更新（股票行情、体育比分）等场景。

### 1.3 WebSocket 与 HTTP 的关系和区别

| **特性**     | **HTTP (HyperText Transfer Protocol)**                       | **WebSocket**                                                |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **通信模式** | **半双工 (Half-duplex)**。客户端发起请求，服务器响应，一次完整的事务结束。 | **全双工 (Full-duplex)**。连接建立后，双方可随时互相发送数据。 |
| **连接状态** | **无状态 (Stateless)**。每个请求都是独立的，服务器不保留之前请求的信息。 | **有状态 (Stateful)**。连接在整个会话期间保持，服务器和客户端都维护连接状态。 |
| **协议开销** | **较高**。每个请求都包含完整的 HTTP 头部，通常有几百字节甚至更多。 | **极低**。握手之后，数据帧的头部非常小（通常 2-10 字节），开销很小。 |
| **连接建立** | 每次通信都需要建立 TCP 连接（或在 Keep-Alive 下复用，但仍是请求-响应模式）。 | **借用 HTTP 协议进行一次“握手”**，之后升级为 WebSocket 协议，后续通信与 HTTP 无关。 |
| **应用场景** | 文档、图片、API 数据等一次性资源获取。                       | 即时聊天、在线协作、实时数据推送、在线游戏等需要高实时性的场景。 |
| **协议标识** | `http://`, `https://`                                        | `ws://`, `wss://`                                            |

### 1.4 WebSocket 的优势与劣势

**优势:**

1. **真正的全双工通信**：低延迟，实时性强。
2. **协议开销小**：握手后数据包头部小，节省带宽。
3. **减少服务器压力**：无需频繁创建和销毁连接。
4. **更好的二进制支持**：可以轻松传输二进制数据（如图片、音频流）。
5. **与 HTTP 协议有良好的兼容性**：握手阶段通过 HTTP/1.1 进行，可以穿越大多数防火墙和代理。

**劣势:**

1. **浏览器兼容性**：虽然现代浏览器普遍支持，但一些老旧浏览器可能需要降级方案（如使用长轮询）。
2. **服务器端实现相对复杂**：相对于无状态的 HTTP，服务器需要维护大量的长连接状态，对服务器的并发处理能力要求更高。
3. **状态管理**：长连接的管理（如心跳检测、断线重连）需要开发者自己实现。

## 第二部分：核心要点

### 2.1 连接建立：握手过程

WebSocket 的连接建立过程非常巧妙，它“伪装”成一个 HTTP 请求，但通过特定的头部字段告知服务器，这是一个请求“升级”协议的请求。

**客户端请求 (Client Request):**

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

- `Upgrade: websocket`: 明确告知服务器，客户端希望将协议从 HTTP 升级到 WebSocket。
- `Connection: Upgrade`: 一个标准的 HTTP/1.1 头部，表示希望升级协议。
- `Sec-WebSocket-Key`: 一个 Base64 编码的随机字符串，用于服务器验证客户端是否是一个真正的 WebSocket 请求。
- `Sec-WebSocket-Version`: 指定了 WebSocket 的协议版本，目前最常用的是 13。

**服务器响应 (Server Response):**

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

- `HTTP/1.1 101 Switching Protocols`: 状态码 `101` 表示服务器同意切换协议。
- `Upgrade: websocket` 和 `Connection: Upgrade`: 服务器确认升级协议。
- `Sec-WebSocket-Accept`: 这是关键的验证字段。服务器将客户端发来的 `Sec-WebSocket-Key` 与一个固定的“魔术字符串” (`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`) 拼接，然后计算 SHA-1 哈希，最后进行 Base64 编码得到该值。客户端会验证这个值，以确认服务器支持 WebSocket。

握手成功后，这条 TCP 连接的“身份”就从 HTTP 变为 WebSocket，后续的数据传输将遵循 WebSocket 的帧格式。

### 2.2 数据传输：数据帧 (Frame)

WebSocket 传输的数据单元被称为**帧 (Frame)**。一个完整的消息可以由一个或多个帧组成。这种设计允许传输大消息时将其分片，避免网络拥塞。

一个简化的帧结构包括：

- **FIN (1 bit)**: 标记是否为消息的最后一个分片。
- **Opcode (4 bits)**: 操作码，定义了帧的类型，如文本帧、二进制帧、关闭帧、Ping/Pong 帧等。
- **Payload length (7 bits, 7+16 bits, or 7+64 bits)**: 载荷数据的长度。
- **Payload data**: 实际传输的数据。

**重点**：由于 WebSocket 自己定义了帧结构，它能明确知道每个数据包的边界，因此天然地解决了 HTTP 协议中可能遇到的“粘包”问题。

### 2.3 心跳机制 (Heartbeat)

由于网络中的路由器、防火墙等设备可能会在一段时间没有数据活动后，自动断开空闲的 TCP 连接。为了维持 WebSocket 长连接的稳定性，需要**心跳机制**。

- **原理**：客户端或服务器定时向对方发送一个特殊的小数据包（通常是 Ping 帧），对方收到后应立即响应一个 Pong 帧。
- **作用**：
  1. **保活 (Keep-Alive)**：通过定时的数据交换，告诉中间网络设备这个连接是活动的，防止被断开。
  2. **连接状态检测**：如果一方在规定时间内没有收到对方的心跳响应，就可以判断连接已经断开，从而进行重连等后续操作。

WebSocket 协议本身定义了 Ping/Pong 帧，但许多应用库也支持在应用层自己实现心跳。

### 2.4 子协议 (Sub-protocols)

`Sec-WebSocket-Protocol` 头部字段允许客户端和服务器协商一个更高层级的“子协议”。这使得 WebSocket 可以在不同的应用场景下（如 WAMP、STOMP 等）使用标准化的消息格式，而不是让每个应用都自定义一套。

### 2.5 安全性 (WSS)

- `ws://` 是非加密的 WebSocket 连接，数据以明文传输，容易被窃听。
- `wss://` (WebSocket Secure) 是加密的 WebSocket 连接，它建立在 TLS (Transport Layer Security) 之上，提供了与 HTTPS 相同的加密、认证和数据完整性保护。

在生产环境中，**必须使用 `wss://`** 来保障通信安全。

### 2.6 生命周期事件

在前端，WebSocket API 提供了清晰的生命周期事件：

- `onopen`: 连接成功建立时触发。
- `onmessage`: 收到服务器消息时触发。
- `onerror`: 通信发生错误时触发。
- `onclose`: 连接关闭时触发（无论正常关闭还是异常断开）。

## 第三部分：常见面试考点

### 基础题

1. **请解释一下什么是 WebSocket。**

   > 答：(参考 1.1) WebSocket 是一种在单个 TCP 连接上实现全双工通信的应用层协议。它的最大特点是，连接一旦建立，服务器和客户端就可以随时互相发送数据，实现了低延迟的实时通信。它通过一个 HTTP 握手来初始化连接，然后将协议“升级”为 WebSocket。

2. **WebSocket 和 HTTP/1.1 的长连接 (Keep-Alive) 有什么区别？**

   > 答：虽然两者都复用 TCP 连接，但本质完全不同。HTTP Keep-Alive 仍然是“请求-响应”模式，客户端不发请求，服务器就不会响应。它只是减少了 TCP 连接的建立次数。而 WebSocket 是真正的全双工模式，没有请求-响应的限制，服务器可以随时主动向客户端推送数据。

3. **WebSocket 和轮询/长轮询相比，有什么优缺点？**

   > 答：(参考 1.2) 相对于轮询和长轮询，WebSocket 的核心优势是：

   > - **性能**：协议开销极小，数据传输效率高。
   >
   > - **实时性**：延迟非常低，是真正的实时双向通信。
   >
   > - 资源消耗：减少了服务器和客户端因频繁请求带来的资源浪费。
   >
   >   缺点是服务器端需要维护连接状态，实现比无状态的 HTTP 更复杂。

4. **描述一下 WebSocket 的握手过程。**

   > 答：(参考 2.1)

   > 1. 客户端发起一个特殊的 HTTP GET 请求。
   > 2. 请求头中包含 `Upgrade: websocket` 和 `Connection: Upgrade`，表示要升级协议。
   > 3. 还包含一个 `Sec-WebSocket-Key`，是一个随机生成的密钥。
   > 4. 服务器收到请求后，如果同意升级，会返回状态码 `101 Switching Protocols`。
   > 5. 服务器会使用客户端的 `Sec-WebSocket-Key` 结合一个“魔术字符串”计算出 `Sec-WebSocket-Accept` 值并返回给客户端。
   > 6. 客户端验证通过后，握手完成，连接升级为 WebSocket 协议。

5. **`Upgrade: websocket` 和 `Connection: Upgrade` 这两个头部字段是做什么用的？**

   > 答：`Connection: Upgrade` 是一个通用的 HTTP/1.1 头部，它告诉接收方，发送方希望升级到一个新的协议。`Upgrade: websocket` 则明确指出了希望升级到的协议是 WebSocket。这两个字段必须同时出现，服务器才会处理这个协议升级请求。

### 进阶题

1. **WebSocket 是如何实现全双工通信的？**

   > 答：WebSocket 的全双工通信是建立在底层的 TCP 协议之上的。TCP 本身就是全双工的。WebSocket 在协议层面去除了 HTTP 的请求-响应约束。握手成功后，客户端和服务器各自维护了一套独立的发送和接收机制，双方都可以通过底层的 TCP 连接随时向对方发送数据帧，而不需要等待对方的任何请求。

2. **什么是 WebSocket 的心跳机制？为什么需要它？如何实现？**

   > 答：(参考 2.3) 心跳机制是指定期发送小数据包以维持连接活跃并检测其状态的一种技术。
   >
   > 为什么需要：主要是为了防止连接因中间网络设备（如 NAT、防火墙）的超时策略而被断开，同时也能及时发现已经失效的“僵尸连接”。
   >
   > 如何实现：

   > - **协议层**：使用 WebSocket 协议内置的 Ping/Pong 帧。客户端定时发送 Ping 帧，服务器收到后自动回复 Pong 帧。
   > - **应用层**：客户端定时发送一个约定的消息（如 `{type: 'heartbeat'}`），服务器收到后回复一个确认消息。这种方式更灵活，可以携带业务数据。通常会设置一个定时器，如果在几个心跳周期内未收到对方响应，则认为连接已断开。

3. **WebSocket 支持传输哪些类型的数据？**

   > 答：WebSocket 协议定义了两种基本的数据类型（通过 Opcode 区分）：

   > - **文本数据 (Text Frame)**：必须是 UTF-8 编码的字符串。
   >
   > - 二进制数据 (Binary Frame)：可以传输任意的二进制数据，如图片、音频、Protobuf 等。
   >
   >   在 JavaScript 中，send() 方法可以接受字符串、Blob、ArrayBuffer 等类型的数据。

4. **如何处理 WebSocket 的连接断开和重连？**

   > 答：

   > 1. **监听 `onclose` 事件**：当连接关闭时，无论是正常关闭还是异常断开，`onclose` 事件都会被触发。
   > 2. **判断断开原因**：可以通过 `close` 事件的 `code` 和 `reason` 属性来判断关闭的原因，区分是服务器主动关闭还是网络问题。
   > 3. **实现重连逻辑**：在 `onclose` 事件回调中执行重连。为了避免在网络持续中断时频繁重连，通常会采用**重连退避策略**，比如第一次失败后 1s 重连，第二次 2s，第三次 4s，以此类推，直到一个最大间隔。
   > 4. **加锁防止重复重连**：设置一个重连状态锁，避免在多个地方同时触发重连操作。
   > 5. **销毁旧实例**：在重连之前，确保之前的 WebSocket 实例已经被清理。

5. **什么是 WSS？它和 WS 有什么关系？**

   > 答：(参考 2.5) WSS (WebSocket Secure) 是 WebSocket 的加密版本。它和 WS 的关系类似于 HTTPS 和 HTTP 的关系。WSS 在标准的 WebSocket 协议基础上，通过 TLS/SSL 层进行加密，提供了数据传输的机密性和完整性，能有效防止中间人攻击。在生产环境中，出于安全考虑，应该始终使用 WSS。

6. **在项目中，你会在什么场景下使用 WebSocket？**

   > 答：(结合自己的项目经验回答)

   > - **即时通讯 (IM)**：如在线聊天室、客服系统。
   > - **协同编辑**：如在线文档、白板，需要实时同步多人的操作。
   > - **实时数据推送**：如股票行情、体育比分、系统监控仪表盘、消息通知。
   > - **在线游戏**：需要实时同步玩家位置、状态等信息。
   > - **视频弹幕**：实时显示用户发送的弹幕。

### 深入题

1. **你知道 WebSocket 的数据帧格式吗？简单描述一下。**

   > 答：(参考 2.2) 是的，WebSocket 的核心是基于帧的传输。每个帧都有一个统一的格式，主要包含：

   > - **FIN 位**：1比特，表示这是否是消息的最后一帧。
   >
   > - **Opcode**：4比特，操作码，定义帧的类型，比如 0x1 是文本，0x2 是二进制，0x8 是关闭，0x9 是 Ping，0xA 是 Pong。
   >
   > - **Mask 位**：1比特，表示是否对载荷数据进行了掩码处理。所有从客户端发往服务器的数据帧，都必须进行掩码。
   >
   > - **Payload Length**：7、7+16 或 7+64 比特，表示载荷数据的长度。
   >
   > - **Masking-key**：0 或 4 字节，如果 Mask 位是 1，则包含 4 字节的掩码密钥。
   >
   > - Payload Data：实际的数据。
   >
   >   这种帧结构的设计，使得协议解析高效，并且能够支持消息分片。

2. **什么是“粘包”问题？WebSocket 是如何解决的？**

   > 答：“粘包”是指在基于 TCP 的流式传输中，由于 TCP 协议本身的特点，接收方一次可能会收到多个数据包（或者一个不完整的数据包），导致无法区分消息的边界。
   >
   > WebSocket 在协议层面解决了这个问题。它通过数据帧 (Frame) 的设计来封装消息。每个帧都有明确的边界和长度信息（Payload Length）。接收方在解析时，会根据帧头部的长度字段来准确地读取每一个帧，从而精确地还原出原始消息，不会发生粘包。

3. **如何实现一个简单的 WebSocket 服务器？（思路或伪代码）**

   > 答：实现一个简单的 WebSocket 服务器主要分为两步：

   > 1. **处理 HTTP 握手**：
   >
   >    - 创建一个 TCP 服务器，监听指定端口。
   >    - 当有客户端连接时，读取 HTTP 请求。
   >    - 检查请求头是否包含 `Upgrade: websocket` 和 `Connection: Upgrade`。
   >    - 如果是，提取 `Sec-WebSocket-Key`。
   >    - 根据协议规范，将 `Sec-WebSocket-Key` 和“魔术字符串”拼接，计算 SHA-1 哈希和 Base64 编码，生成 `Sec-WebSocket-Accept`。
   >    - 构造一个 HTTP 101 响应，包含 `Sec-WebSocket-Accept`，并发送给客户端。
   >
   > 2. **处理 WebSocket 数据帧**：
   >
   >    - 握手成功后，开始监听来自该 TCP 连接的数据。
   >
   >    - 按照 WebSocket 的帧格式解析收到的二进制数据：读取 FIN, Opcode, Payload Length 等。
   >
   >    - 如果是来自客户端的数据，需要用掩码密钥进行解码。
   >
   >    - 根据 Opcode 处理不同类型的帧（如文本/二进制数据、Ping/Pong、关闭请求）。
   >
   >    - 当服务器要发送数据时，需要将数据封装成 WebSocket 帧格式（不需要掩码），然后通过 TCP 连接发送出去。
   >
   >      （在实际开发中，我们通常会使用成熟的库，如 Node.js 的 ws 或 Socket.IO，Java 的 Spring WebSocket 等，它们已经处理好了这些底层细节。）

4. **在集群环境下，如何管理和扩展 WebSocket 连接？**

   > 答：集群环境下管理 WebSocket 的核心挑战是，一个用户的多个请求可能被负载均衡器分发到不同的服务器实例上，但 WebSocket 连接是有状态的，必须维持在建立握手的那个实例上。

   > - **粘性会话 (Sticky Sessions)**：通过负载均衡器（如 Nginx）配置，确保来自同一个客户端的所有请求都被路由到同一台后端服务器。这是最简单的方案，但如果该服务器宕机，连接就会丢失。
   > - **外部存储/消息队列**：将用户的连接信息（如用户ID与服务器实例的映射关系）存储在外部共享服务中（如 Redis）。当一台服务器需要向特定用户发送消息时，它首先查询 Redis 找到该用户连接在哪台服务器，然后通过消息队列（如 RabbitMQ, Kafka）将消息推送到目标服务器，再由目标服务器将消息通过 WebSocket 发送给客户端。这种架构解耦了服务实例，扩展性更好。

5. **WebSocket 的浏览器兼容性如何？如何做降级处理？**

   > 答：目前所有现代浏览器（Chrome, Firefox, Safari, Edge）都已良好支持 WebSocket。主要的兼容性问题存在于一些非常古老的浏览器，如 IE9 及以下。
   >
   > 降级处理 (Fallback)：

   > - **特征检测**：在代码中检查 `window.WebSocket` 对象是否存在，如果不存在，则说明浏览器不支持。
   > - **自动降级库**：使用一些成熟的库，如 **Socket.IO** 或 **SockJS**。这些库封装了 WebSocket API，并能在浏览器不支持 WebSocket 的情况下，自动、透明地降级到其他技术，如长轮询、AJAX 轮询等，对开发者屏蔽了底层细节，是最佳实践。

## 第四部分：总结

面试时，对 WebSocket 的考察可以从“是什么”、“为什么用”、“怎么用”以及“深入原理”四个层面展开。

- **是什么**：清晰定义全双工、有状态、低开销。
- **为什么用**：能够与 HTTP 轮询、长轮询进行对比，说出其优势和适用场景。
- **怎么用**：熟悉握手过程、生命周期事件、心跳和重连机制。
- **深入原理**：了解数据帧结构、WSS 安全、集群扩展方案。

准备面试时，不仅要记住这些概念，更要尝试结合自己的项目经验，说明在实际工作中是如何应用 WebSocket 解决问题的。祝你面试顺利！
