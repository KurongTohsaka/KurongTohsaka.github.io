<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《Kubernetes微服务实战》记录 | KurongBlog</title>
<meta name=keywords content="微服务,Kubernetes"><meta name=description content="《Kubernetes微服务实战》记录
面向开发人员的 Kubernetes 简介
部分核心概念

Node：Node 是 Kubernetes 集群中的一个工作单元，表示集群中的一台物理机或虚拟机。Node 的作用是为运行容器化应用提供计算资源，一个 Node 可以运行多个 Pod。Node 分为：

Master Node：负责集群的控制平面，管理所有工作节点。
Worker Node：运行实际的应用程序工作负载，实际上就是 Pod。


Pod：Pod 是 Kubernetes 中最小的可部署单位，表示一个或多个容器的集合。有以下特性：

Pod 内的容器共享一个 IP 地址，可以通过 localhost 相互通信。
Pod 内的容器可以共享挂载的存储卷（Volume）。
Pod 通常包含运行同一应用程序组件的容器，如主应用程序容器、日志采集容器等。


Namespace：用于逻辑上隔离资源。可以在同一集群中运行多个项目或团队的工作负载。
Service：用于将一组 Pod 的访问暴露给外部或集群内部的其他 Pod。
Deployment：用于声明和管理 Pod 的期望状态，例如副本数、滚动更新等。
Volume：提供持久化存储，允许 Pod 重启后数据仍然保留。

Kubernetes 架构
每个集群都有一个控制平面和数据平面，数据平面由多个节点组成，控制平面将在这些节点上部署并运行 Pod（容器组），监控变更并做出响应。
控制平面包含以下组件：

API 服务器。
etcd 存储。
调度器：kube 调度器负责将 Pod 调度到工作节点。
控制器管理器：kube 控制器管理器是包含多个控制器的单个进程，这些控制器监控着集群事件和对集群的更改做出响应。

节点控制器：负责在节点出现故障时进行通知和响应。
副本控制器：确保每个副本集（replica set）或副本控制器对象中有正确数量的 Pod 。
端点控制器：为每个服务分配一个列出该服务的 Pod 的端点对象。
服务账户和令牌控制器：使用默认服务账户和响应的 API 访问令牌对新的命名空间进行初始化。



数据平面是集群中将容器化工作负载转为 Pod 运行的节点的集合。"><meta name=author content="Kurong"><link rel=canonical href=http://localhost:1313/posts/dailydev/kubernetes%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/dailydev/kubernetes%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><meta property="og:title" content="《Kubernetes微服务实战》记录"><meta property="og:description" content="《Kubernetes微服务实战》记录
面向开发人员的 Kubernetes 简介
部分核心概念

Node：Node 是 Kubernetes 集群中的一个工作单元，表示集群中的一台物理机或虚拟机。Node 的作用是为运行容器化应用提供计算资源，一个 Node 可以运行多个 Pod。Node 分为：

Master Node：负责集群的控制平面，管理所有工作节点。
Worker Node：运行实际的应用程序工作负载，实际上就是 Pod。


Pod：Pod 是 Kubernetes 中最小的可部署单位，表示一个或多个容器的集合。有以下特性：

Pod 内的容器共享一个 IP 地址，可以通过 localhost 相互通信。
Pod 内的容器可以共享挂载的存储卷（Volume）。
Pod 通常包含运行同一应用程序组件的容器，如主应用程序容器、日志采集容器等。


Namespace：用于逻辑上隔离资源。可以在同一集群中运行多个项目或团队的工作负载。
Service：用于将一组 Pod 的访问暴露给外部或集群内部的其他 Pod。
Deployment：用于声明和管理 Pod 的期望状态，例如副本数、滚动更新等。
Volume：提供持久化存储，允许 Pod 重启后数据仍然保留。

Kubernetes 架构
每个集群都有一个控制平面和数据平面，数据平面由多个节点组成，控制平面将在这些节点上部署并运行 Pod（容器组），监控变更并做出响应。
控制平面包含以下组件：

API 服务器。
etcd 存储。
调度器：kube 调度器负责将 Pod 调度到工作节点。
控制器管理器：kube 控制器管理器是包含多个控制器的单个进程，这些控制器监控着集群事件和对集群的更改做出响应。

节点控制器：负责在节点出现故障时进行通知和响应。
副本控制器：确保每个副本集（replica set）或副本控制器对象中有正确数量的 Pod 。
端点控制器：为每个服务分配一个列出该服务的 Pod 的端点对象。
服务账户和令牌控制器：使用默认服务账户和响应的 API 访问令牌对新的命名空间进行初始化。



数据平面是集群中将容器化工作负载转为 Pod 运行的节点的集合。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/dailydev/kubernetes%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-25T00:00:00+00:00"><meta property="og:site_name" content="KurongBlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="《Kubernetes微服务实战》记录"><meta name=twitter:description content="《Kubernetes微服务实战》记录
面向开发人员的 Kubernetes 简介
部分核心概念

Node：Node 是 Kubernetes 集群中的一个工作单元，表示集群中的一台物理机或虚拟机。Node 的作用是为运行容器化应用提供计算资源，一个 Node 可以运行多个 Pod。Node 分为：

Master Node：负责集群的控制平面，管理所有工作节点。
Worker Node：运行实际的应用程序工作负载，实际上就是 Pod。


Pod：Pod 是 Kubernetes 中最小的可部署单位，表示一个或多个容器的集合。有以下特性：

Pod 内的容器共享一个 IP 地址，可以通过 localhost 相互通信。
Pod 内的容器可以共享挂载的存储卷（Volume）。
Pod 通常包含运行同一应用程序组件的容器，如主应用程序容器、日志采集容器等。


Namespace：用于逻辑上隔离资源。可以在同一集群中运行多个项目或团队的工作负载。
Service：用于将一组 Pod 的访问暴露给外部或集群内部的其他 Pod。
Deployment：用于声明和管理 Pod 的期望状态，例如副本数、滚动更新等。
Volume：提供持久化存储，允许 Pod 重启后数据仍然保留。

Kubernetes 架构
每个集群都有一个控制平面和数据平面，数据平面由多个节点组成，控制平面将在这些节点上部署并运行 Pod（容器组），监控变更并做出响应。
控制平面包含以下组件：

API 服务器。
etcd 存储。
调度器：kube 调度器负责将 Pod 调度到工作节点。
控制器管理器：kube 控制器管理器是包含多个控制器的单个进程，这些控制器监控着集群事件和对集群的更改做出响应。

节点控制器：负责在节点出现故障时进行通知和响应。
副本控制器：确保每个副本集（replica set）或副本控制器对象中有正确数量的 Pod 。
端点控制器：为每个服务分配一个列出该服务的 Pod 的端点对象。
服务账户和令牌控制器：使用默认服务账户和响应的 API 访问令牌对新的命名空间进行初始化。



数据平面是集群中将容器化工作负载转为 Pod 运行的节点的集合。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"《Kubernetes微服务实战》记录","item":"http://localhost:1313/posts/dailydev/kubernetes%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《Kubernetes微服务实战》记录","name":"《Kubernetes微服务实战》记录","description":"《Kubernetes微服务实战》记录 面向开发人员的 Kubernetes 简介 部分核心概念 Node：Node 是 Kubernetes 集群中的一个工作单元，表示集群中的一台物理机或虚拟机。Node 的作用是为运行容器化应用提供计算资源，一个 Node 可以运行多个 Pod。Node 分为： Master Node：负责集群的控制平面，管理所有工作节点。 Worker Node：运行实际的应用程序工作负载，实际上就是 Pod。 Pod：Pod 是 Kubernetes 中最小的可部署单位，表示一个或多个容器的集合。有以下特性： Pod 内的容器共享一个 IP 地址，可以通过 localhost 相互通信。 Pod 内的容器可以共享挂载的存储卷（Volume）。 Pod 通常包含运行同一应用程序组件的容器，如主应用程序容器、日志采集容器等。 Namespace：用于逻辑上隔离资源。可以在同一集群中运行多个项目或团队的工作负载。 Service：用于将一组 Pod 的访问暴露给外部或集群内部的其他 Pod。 Deployment：用于声明和管理 Pod 的期望状态，例如副本数、滚动更新等。 Volume：提供持久化存储，允许 Pod 重启后数据仍然保留。 Kubernetes 架构 每个集群都有一个控制平面和数据平面，数据平面由多个节点组成，控制平面将在这些节点上部署并运行 Pod（容器组），监控变更并做出响应。\n控制平面包含以下组件：\nAPI 服务器。 etcd 存储。 调度器：kube 调度器负责将 Pod 调度到工作节点。 控制器管理器：kube 控制器管理器是包含多个控制器的单个进程，这些控制器监控着集群事件和对集群的更改做出响应。 节点控制器：负责在节点出现故障时进行通知和响应。 副本控制器：确保每个副本集（replica set）或副本控制器对象中有正确数量的 Pod 。 端点控制器：为每个服务分配一个列出该服务的 Pod 的端点对象。 服务账户和令牌控制器：使用默认服务账户和响应的 API 访问令牌对新的命名空间进行初始化。 数据平面是集群中将容器化工作负载转为 Pod 运行的节点的集合。\n","keywords":["微服务","Kubernetes"],"articleBody":"《Kubernetes微服务实战》记录 面向开发人员的 Kubernetes 简介 部分核心概念 Node：Node 是 Kubernetes 集群中的一个工作单元，表示集群中的一台物理机或虚拟机。Node 的作用是为运行容器化应用提供计算资源，一个 Node 可以运行多个 Pod。Node 分为： Master Node：负责集群的控制平面，管理所有工作节点。 Worker Node：运行实际的应用程序工作负载，实际上就是 Pod。 Pod：Pod 是 Kubernetes 中最小的可部署单位，表示一个或多个容器的集合。有以下特性： Pod 内的容器共享一个 IP 地址，可以通过 localhost 相互通信。 Pod 内的容器可以共享挂载的存储卷（Volume）。 Pod 通常包含运行同一应用程序组件的容器，如主应用程序容器、日志采集容器等。 Namespace：用于逻辑上隔离资源。可以在同一集群中运行多个项目或团队的工作负载。 Service：用于将一组 Pod 的访问暴露给外部或集群内部的其他 Pod。 Deployment：用于声明和管理 Pod 的期望状态，例如副本数、滚动更新等。 Volume：提供持久化存储，允许 Pod 重启后数据仍然保留。 Kubernetes 架构 每个集群都有一个控制平面和数据平面，数据平面由多个节点组成，控制平面将在这些节点上部署并运行 Pod（容器组），监控变更并做出响应。\n控制平面包含以下组件：\nAPI 服务器。 etcd 存储。 调度器：kube 调度器负责将 Pod 调度到工作节点。 控制器管理器：kube 控制器管理器是包含多个控制器的单个进程，这些控制器监控着集群事件和对集群的更改做出响应。 节点控制器：负责在节点出现故障时进行通知和响应。 副本控制器：确保每个副本集（replica set）或副本控制器对象中有正确数量的 Pod 。 端点控制器：为每个服务分配一个列出该服务的 Pod 的端点对象。 服务账户和令牌控制器：使用默认服务账户和响应的 API 访问令牌对新的命名空间进行初始化。 数据平面是集群中将容器化工作负载转为 Pod 运行的节点的集合。\nK8s 会在每个节点上安装一些组件以进行 Pod 的通信、监控和调度，包括：\nkublet ：是 K8s 的代理，负责与 API 服务器进行通信，并运行和管理在节点上的 Pod 。 kube proxy ：负责节点的网络连接，充当服务的本地前端，并且可以转发 TCP 和 UDP 数据包。它通过 DNS 或环境变量来发现服务的 IP 地址。 容器运行时：Docker、gRPC 。 kubectl ：命令行工具 CLI 。 微服务的完美搭档 ReplicaSet 是具有一定数量副本的 Pod 集合，创建它时 K8s 会确保始终有指定数量的 Pod 在集群中运行。以下是一个 K8s 部署清单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion: apps/v1 # 用来标记 K8s 的资源版本 kind: Deployment # 指定处理的资源或 API 对象 metadata: name: nginx # 用来引用此特定资源 labels: # 标签允许 K8s 对共享相同标签的一组资源进行操作 app: nginx spec: # Deployment 的规范 replicas: 3 # 副本数 selector: # 选择器，管理具有与 matchLabels 匹配的标签的 Pod matchLabels: app: nginx template: # Pod 模板 metadata: labels: app: nginx spec: # Pod 的规范 containers: - name: nginx image: nginx:1.15.4 ports: - containerPort: 80 K8s 提供了 Service 服务资源，用于微服务的公开和发现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 apiVersion: v1 kind: Service metadata: name: nginx-service # Service 名称 labels: app: nginx spec: selector: # 选择与 Deployment 中标签匹配的 Pod app: nginx ports: - protocol: TCP port: 80 # Service 的端口 targetPort: 80 # 映射到 Pod 的 containerPort type: ClusterIP # Service 类型，默认为 ClusterIP 关于微服务安全，K8s 有以下措施：\n通过命名空间将集群的不同部分相互隔离。 服务账户和权限。 密钥管理。 利用客户端证书对任何外部通信进行双重认证，如 HTTPS。 通过网络策略，定义和调整集群中的网络流量和访问。 使用 K8s 扩展微服务有两种方式，这两个方式都可以通过更新部署的副本数显式扩展微服务：\n扩展 Pod 的数量。 扩展集群的总容量。 同时，K8s 可以对 Pod、资源等进行监控，日志也实现了集中管理。\n使用 Kubernetes 配置微服务 使用 Kubernetes ConfigMap ConfigMap 是用于存储非机密配置信息的资源对象，它通常用来管理应用程序所需的配置数据。大概形式如下：\n1 2 3 4 5 6 7 apiVersion: v1 kind: ConfigMap metadata: name: my-config data: config1: value1 config2: value2 要想让 Pod 使用 ConfigMap 则有三种使用方式：\n作为环境变量：将 ConfigMap 中的值注入到容器的环境变量中：\n1 2 3 4 5 6 env: - name: CONFIG1 valueFrom: configMapKeyRef: name: my-config key: config1 挂载为文件：\n1 2 3 4 5 6 7 volumes: - name: config-volume configMap: name: my-config volumeMounts: - mountPath: /etc/config name: config-volume 作为命令行参数。\n使用 ConfigMap 可以实现配置动态更新，而且使配置易于管理。\n服务发现 K8s 内置了服务发现功能，无需做其他工作。每个服务都有一个端点资源，K8s 会使这个端点与运行该服务的容器地址保持同步。注意，每个 Pod 都有自己的 IP 地址，只有 API 服务器具有公共 IP 地址。每个服务都通过 DNS 和环境变量自动公开给集群中的其他服务：\nDNS：K8s 默认会使用 CoreDNS 提供内部的 DNS 服务，所有 Service 都会被注册到集群的 DNS 系统中，从而可以通过域名进行访问。DNS 是动态的，能够实时解析 Service 的 ClusterIP，因此即使 Service 的后端 Pod 实例发生变化（如扩缩容），DNS 解析仍然有效。 环境变量：当一个 Pod 被创建时，K8s 会将集群中每个 Service 的相关信息（例如 IP 和端口）注入到 Pod 的环境变量中。环境变量是静态的，仅在 Pod 创建时生成，因此如果 Service 的 IP 发生变化（例如重建），需要重启 Pod 才能更新环境变量。 Kubernetes 与微服务安全 用户账户和服务账户 用户账户代表人类用户（管理员、开发者等），是外部用户与 K8s API 的交互身份。K8s 不直接创建或管理用户账户的生命周期，通常需要集成外部认证系统。\n服务账户用于代表运行在集群中的应用程序或 Pod，是 Pod 与K8s API 的交互身份。默认情况下，每个命名空间都会有一个名为 default 的服务账户，Pod 没有指定服务账户时会自动绑定到这个默认账户。服务账户通过挂载到 Pod 的服务账户 Token 来认证自己。而且服务账户是命名空间作用域的，不能跨命名空间使用。\n使用 Kubernetes 管理密钥 K8s 中的密钥通常有三种：\n服务账户的 API Token 。 私有镜像仓库密钥。 Opaque 密钥，这是 K8s 不知道的密钥，可以将敏感信息存储在这里。它提供了一个安全的密钥存储库，以及管理密钥的 API 。 在使用密钥时，可以将密钥打包到容器里、存储到环境变量、挂载为文件。\nAPI 与负载均衡器 Kubernetes 的服务 K8s 的服务必须属于下面的某种类型：\nClusterIP（默认值）：只能在集群内访问该服务，这是和微服务之间相互通信。 NodePort：该服务通过所有节点上的专用端口对外开放。当请求通过专用 NodePort 进入节点时，kubelet 将负责将其转发到 Pod 所在节点。 LoadBalancer：当 K8s 集群运行在提供负载均衡器支持的云平台上时，该类服务较常见。 ExternalName：该类服务将对服务的请求解析为外部提供的 DNS 名称。 东西流量和南北流量 东西流量指服务/Pod/容器在集群内的相互通信。南北流量指对外公开服务的通信。\ningress 和负载均衡器 关于 ingress ：\ningress 是 K8s 中的一种资源对象，用于管理外部 HTTP/HTTPS 流量如何访问集群内部的服务。 ingress 可以定义域名的路由规则、支持 TLS/HTTPS 加密、提供统一入口来管理多个服务。 ingress 由 ingress 控制器和 ingress 资源组成。前者处理 ingress 规则的实现，后者为用户定义的规则和配置。 关于负载均衡器：\n负载均衡器通常指将流量分发给多个 Pod 的机制，分为内部负载均衡和外部负载均衡。 内部负载均衡： K8s 的 Service 对象自带负载均衡功能。 Service 的 ClusterIP 会在集群内部均衡流量到不同的 Pod。 外部负载均衡： 在云环境中，Service 的类型设置为 LoadBalancer 时，会创建一个云提供商的负载均衡器（如 AWS ELB、GCP Load Balancer）。 通过负载均衡器将外部流量引入到 K8s 服务中。 通过消息队列发送和接收事件 NATS 是一款高性能、轻量级的开源消息系统，广泛用于分布式系统和云原生应用中。这是一个 CNCF 项目，由 Go 实现。它采用发布-订阅（Pub/Sub）、请求-响应（Request-Reply）以及队列（Queue）通信模式，设计目标是简单、快速和可靠。\n有状态服务 抽象存储 K8s 的存储模型包含以下几个概念：\n卷：是 K8s 中最基本的存储单元，用于为 Pod 提供持久化存储。\n持久卷：是集群级别的存储资源，由管理员进行配置。\n持久卷声明：是用户对存储资源的请求，类似于 Pod 对计算资源的请求。持久卷声明与持久卷绑定，Pod 通过持久卷声明使用持久卷。\n存储类：用于动态创建持久卷，允许按需分配存储资源。每个存储类对应一种存储后端（如SSD、HDD），并定义了持久卷的属性（如卷类型、回收策略）。\n动态供给：允许根据持久卷声明自动创建持久卷，无需管理员手动干预。\nCSI（容器存储接口）：是 K8s 与存储插件之间的标准接口，允许第三方存储提供商集成。\n使用 StatefulSet 在 Kubernetes 集群内存储数据 StatefulSet 是K8s 中用于管理有状态应用的工作负载 API 对象。与 Deployment 不同，StatefulSet 为每个 Pod 提供唯一的标识和稳定的网络标识、持久化存储，确保 Pod 在重启、迁移或扩展时保持一致性。StatefulSet 适用于需要稳定网络标识、有序部署和持久化存储的应用，如数据库（MySQL、PostgreSQL）、分布式系统（Zookeeper、Kafka）等。\nStatefulSet 有一些核心特性：\n稳定的网络标识：每个 Pod 都有一个唯一的、稳定的网络标识（如 pod-name-0, pod-name-1），即使 Pod 被重新调度，其名称和网络标识也不会改变。 有序部署和扩展：Pod 的创建和扩展是按顺序进行的。 有序终止和缩容：Pod 的删除是按逆序进行的。 持久化存储：每个 Pod 可以绑定一个独立的持久卷，确保数据在 Pod 重启或迁移时不会丢失。 稳定存储：通过配置，StatefulSet 可以为每个 Pod 动态的创建持久卷声明。 StatefulSet 通常与 Headless Service 使用。Headless Service 不会分配 ClusterIP，而是直接返回 Pod 的 IP 和 DNS 记录。\n下面是一个 StatefulSet 配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: serviceName: \"nginx\" # 关联的 Headless Service 名称 replicas: 3 # Pod 副本数 selector: matchLabels: app: nginx # 匹配 Pod 的标签 template: metadata: labels: app: nginx # Pod 的标签 spec: containers: - name: nginx image: nginx:latest ports: - containerPort: 80 volumeMounts: - name: www # 挂载的卷名称 mountPath: /usr/share/nginx/html volumeClaimTemplates: # 动态创建 PVC - metadata: name: www # PVC 名称 spec: accessModes: [ \"ReadWriteOnce\" ] resources: requests: storage: 1Gi # 存储大小 在 Kubernetes 中使用关系型和非关系型数据库 使用 StatefulSet 部署 MySQL：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 apiVersion: apps/v1 kind: StatefulSet metadata: name: mysql spec: serviceName: \"mysql\" replicas: 3 selector: matchLabels: app: mysql template: metadata: labels: app: mysql spec: containers: - name: mysql image: mysql:5.7 env: - name: MYSQL_ROOT_PASSWORD value: \"password\" ports: - containerPort: 3306 volumeMounts: - name: mysql-data mountPath: /var/lib/mysql volumeClaimTemplates: - metadata: name: mysql-data spec: accessModes: [ \"ReadWriteOnce\" ] resources: requests: storage: 10Gi 使用 StatefulSet 部署 Redis：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 apiVersion: apps/v1 kind: StatefulSet metadata: name: redis spec: serviceName: \"redis\" # 关联的 Headless Service 名称 replicas: 3 # Redis 实例数量 selector: matchLabels: app: redis # 匹配 Pod 的标签 template: metadata: labels: app: redis # Pod 的标签 spec: containers: - name: redis image: redis:6.2 # Redis 镜像 ports: - containerPort: 6379 # Redis 默认端口 volumeMounts: - name: redis-data # 挂载的卷名称 mountPath: /data # Redis 数据目录 volumeClaimTemplates: # 动态创建 PVC - metadata: name: redis-data # PVC 名称 spec: accessModes: [ \"ReadWriteOnce\" ] # 访问模式 resources: requests: storage: 1Gi # 存储大小 这是 Redis 的 Headless Service 配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion: v1 kind: Service metadata: name: redis labels: app: redis spec: clusterIP: None # Headless Service ports: - port: 6379 # Redis 默认端口 name: redis selector: app: redis # 匹配 StatefulSet 的 Pod 标签 在 Kubernetes 上运行 Serverless 任务 云中的 Serverless Serverless（无服务器）是一种云计算模式，在这种模式下，开发者不需要管理服务器或底层基础设施，而是专注于业务代码的编写。所有的基础资源（计算、存储、网络等）由云服务提供商自动管理和调度。\n在 Serverless 模式中，应用被拆分为一个个独立的函数（即“函数即服务”，FaaS），每个函数只在特定事件触发时运行。云平台会根据请求的数量动态分配资源，并根据实际运行时间收费。例如，当一个 HTTP 请求触发一个函数时，该函数就会被加载、执行，并在完成后自动销毁，用户只需为这段实际运行的时间付费。\nServerless的优缺点：\n优势： 降低运维复杂度，开发者可专注于业务逻辑。 经济高效，按需计费模式避免资源浪费。 弹性扩展，能够快速应对流量变化。 局限： 冷启动问题：长时间不调用的函数可能存在首次调用延迟。 依赖云服务商：可能会受到厂商锁定（vendor lock-in）的影响。 调试和监控较为复杂：由于执行环境由云平台管理，本地调试和日志追踪可能不如传统服务直观。 常见的 Serverless 框架 Nuclio：一个知名的 Serverless 平台，支持高性能、低延迟的函数执行。 Knative：由 Google 等公司主导开发，Knative 提供了构建、部署和管理 Serverless 应用的完整解决方案。与 Kubernetes 深度集成，支持蓝绿部署、滚动更新和无缝扩展，适用于构建大规模、云原生的 Serverless 应用。 Kubeless：Kubeless 是一个原生 K8s 的 Serverless 框架，允许用户以 YAML 文件的形式直接部署函数。适合中小型应用或实验性项目，快速上手部署简单的函数服务。 OpenFaaS：OpenFaaS（Functions as a Service）通过 Docker 容器化的方式来封装函数，提供了简洁的 UI 和 CLI 工具。适用于混合云和多云环境中快速构建和部署 Serverless 应用。 Fission：Fission 是一个专为 K8s 设计的 Serverless 框架，以低延迟和高性能著称。适合对响应速度有较高要求的业务场景，能够高效处理大量短时间任务。 微服务的部署 部署对象 Depolyment：Deployment 是最常用的部署对象，主要用于管理无状态（Stateless）的应用。它定义了 Pod 模板、期望副本数、更新策略等，并通过管理底层的 ReplicaSet 实现 Pod 的创建、扩缩容和滚动升级。 StatefulSet：用于管理有状态（Stateful）的应用，如数据库或分布式存储系统。它提供了稳定的网络标识、持久化存储绑定以及有序的启动和终止顺序。 DaemonSet：保证集群中每个（或指定一部分）节点上都运行一个 Pod。常用于部署日志收集、监控代理、安全扫描等守护进程。 ReplicaSet：用于保证一组 Pod 始终保持在指定的副本数量。通常由 Deployment 控制，不需要直接创建，但在一些场景下也可以单独使用。 多环境部署 在实际开发和运维过程中，通常需要在不同的环境（如开发、测试、预发布、生产）中部署应用。多环境部署主要关注环境隔离、配置管理和自动化流程等问题。\nNameSpace 隔离：K8s 中的 Namespace 用于逻辑隔离资源。不同环境可以分配不同的 Namespace，如 dev、staging、prod。这不仅便于资源管理，还能设置不同的资源配额和权限控制策略。 配置管理：利用 ConfigMap 管理非敏感配置信息，利用 Secret 管理敏感信息。不同环境下的配置可以通过不同的 ConfigMap/Secret 来区分，再通过环境变量或挂载文件的方式传递给 Pod。或者部署时可利用 YAML 文件中 env 字段注入环境变量，或使用 args/command 自定义启动参数，实现同一镜像在不同环境下的不同行为。 Helm：Helm 是 K8s 的包管理工具，通过 Chart 定义应用的各种资源。借助 Helm，可以使用同一个 Chart 针对不同环境传入不同的 values 参数，实现配置复用与环境定制化部署。 CI/CD：通过 CI/CD 工具（如 Jenkins、GitLab CI、Argo CD 等）实现代码构建、镜像打包、自动测试以及自动部署。流水线中可设置不同的分支对应不同环境，并在每次提交后自动触发相应环境的部署更新。利用 CI/CD 流水线自动化部署的同时，可以记录每次部署的版本信息，结合 K8s 自身的回滚能力，实现快速恢复和版本切换。 高级部署策略 滚动更新：滚动更新是一种渐进式更新策略，通过逐步替换旧版 Pod 为新版 Pod 来实现应用升级，确保在整个过程中服务始终可用。 无需中断服务，更新过程透明。 可以根据流量情况和节点容量动态控制更新速率。 蓝绿部署：蓝绿部署将旧版本（蓝）与新版本（绿）完全隔离部署在不同的环境中，通过切换流量路由实现版本切换。通常利用外部负载均衡器（或 Ingress 控制器）进行流量切换。 可快速回滚，降低风险。 测试与验证环境独立，不影响现有业务。 金丝雀发布：金丝雀发布是指将新版本部署到少量 Pod 上，先让少部分流量进入新版本以验证稳定性，再逐步扩大新版本的流量比例，最终完全替换旧版本。 降低新版本升级风险。 在实际流量中验证新版本的性能和稳定性，及时发现潜在问题。 A/B 测试和灰度发布：A/B 测试指在相同的生产环境中，同时部署两个或多个版本，通过不同用户组的反馈和数据对比，选择最优方案。类似于金丝雀发布，但灰度发布往往针对特定用户或特定条件进行版本切换，既可以逐步扩大流量，也可以根据用户特征精细控制版本分布。 监控、日志和指标 自愈机制 自愈是 K8s 集群中一个核心特性，指的是集群能够在发生故障或异常时，自动将实际状态恢复到期望状态，保证系统持续可用。主要体现在以下几个方面：\n控制器自愈\nDeployment、ReplicaSet 和 StatefulSet 控制器： 声明式管理：通过定义期望状态，K8s 控制器会不断对比实际状态，如发现 Pod 崩溃、失联或数量不足时，自动重启或创建新的 Pod。 滚动升级和回滚：在更新过程中，如果发现新版本出现问题，可以自动回滚到稳定版本，保证服务不中断。 健康检查（Liveness \u0026 Readiness Probes）\nLiveness Probe：\n作用：检测应用是否处于健康状态，如发现故障则重启容器。 实现：通过 HTTP 请求、TCP 检查或执行命令来判断容器状态。 Readiness Probe：\n作用：判断容器是否已经准备好接收流量，避免在启动或更新过程中将流量导入未就绪的容器。 自动重调度与节点自愈\n节点状态监控：K8s 的 Node Controller 会定期检测节点的健康状态，一旦发现节点失联或状态异常，会将该节点标记为不可用，并将其上运行的 Pod 调度到其他健康节点上。\nPod 重启策略：若容器因内部错误退出，Pod 会按照重启策略（如 Always、OnFailure、Never）自动进行重启，确保服务恢复。\n集群自动伸缩 集群自动伸缩（Autoscaling）是提高资源利用率和降低成本的重要手段，主要分为 Pod 级别的自动伸缩和节点级别的自动伸缩。\nPod 级别自动伸缩\nHorizontal Pod Autoscaler (HPA)\n作用：根据应用实际的 CPU、内存或者自定义指标，对 Deployment、ReplicaSet、StatefulSet 中的 Pod 数量进行动态调整。\n工作原理：\nHPA 定期查询指定指标数据（通常由 Prometheus Adapter 或 Metrics Server 提供），与设定的目标值比较。 若指标超出目标范围，则按比例增加 Pod 副本；若指标低于目标范围，则减少 Pod 数量。 Vertical Pod Autoscaler (VPA)\n作用：根据 Pod 的资源使用情况，自动调整容器的 CPU 和内存请求与限制，帮助在固定 Pod 数量下优化资源分配。\n特点：\n适用于难以通过增加副本解决资源瓶颈的场景。 配置和调整相对复杂，可能需要重启 Pod 生效。 节点级别自动伸缩\nCluster Autoscaler\n作用：针对托管在云平台上的 K8s 集群（如 AWS EKS、GKE、AKS 等），当集群内资源不足（无法调度新 Pod）时，自动增加节点；当节点长期处于低负载、空闲状态时，自动缩减节点数，降低成本。\n工作原理：\n持续监控调度器的排队情况和节点资源利用率。 在 Pod 无法调度时，向云平台 API 请求增加节点；在节点空闲且 Pod 可迁移时，安全驱逐并缩减节点数。 监控 主要组件和工具：\nPrometheus： 作用：开源监控系统和时序数据库，专门用于抓取、存储和查询各种指标数据。 采集方式：通过 HTTP Pull 模式定时抓取目标暴露的指标（通常为 /metrics 接口）。 Grafana： 作用：数据可视化工具，可以与 Prometheus 等时序数据库配合，通过仪表板展示实时和历史指标数据。 功能：支持自定义告警规则、报表制作和数据关联分析，帮助运维人员直观地监控集群运行情况。 Alertmanager： 作用：与 Prometheus 配合使用，实现告警信息的分组、抑制和路由。 告警渠道：支持邮件、Slack、PagerDuty 等多种告警方式，便于及时通知相关人员。 日志 日志采集方式：\n容器标准输出：K8s 中容器的日志一般输出到标准输出（stdout）和标准错误（stderr），由 kubelet 写入宿主机上的日志文件（通常在 /var/log/containers）。 DaemonSet 日志采集器：在每个节点上部署日志采集代理（如 Fluentd、Filebeat 或 Logstash），以 DaemonSet 的方式运行，保证所有节点的日志能够被采集并转发到集中式日志存储系统中。 常见日志系统：\nELK/EFK Stack： Elasticsearch：日志存储和检索引擎，可以存储海量日志数据，并支持高效查询。 Logstash/Fluentd：日志采集和处理工具，负责解析、过滤并将日志数据传输到 Elasticsearch。 Kibana：数据可视化和分析工具，通过图形化界面帮助运维人员快速定位问题。 Loki + Promtail + Grafana： Loki：由 Grafana Labs 开发的日志聚合系统，专门设计用于与 Prometheus 数据模型兼容，并与 Grafana 紧密集成。 Promtail：日志采集器，类似于 Fluentd，但与 Loki 集成更紧密。 指标 自定义指标：利用 Prometheus Client 库（如 Prometheus Python Client、Java Client 等）在应用中嵌入指标采集功能，暴露 HTTP 接口供 Prometheus 抓取。 Kubernetes 内置指标：如 cAdvisor 提供容器级别的资源使用情况，kube-state-metrics 提供集群状态信息。 展示与告警：利用 Grafana 等工具构建仪表板，并设置阈值告警，确保在关键指标异常时能迅速通知运维人员。 服务网格与 Istio 服务网格 随着微服务架构的普及，单个应用被拆分为众多独立服务，各服务之间通信频繁且复杂，传统的点对点通信往往需要在每个服务中自行实现流量管理、重试、熔断、认证等功能，导致代码重复、运维困难。服务网格正是为了解决这些问题而诞生的。\n服务网格是一种专门用于管理微服务之间通信的基础设施层，它将服务间的网络通信抽象出来，形成一层独立于业务逻辑之外的透明代理层。通过这种方式，开发者可以将流量路由、负载均衡、故障恢复、安全认证、监控等能力从应用代码中分离出来，由网格层统一管理。\nIstio Istio 作为目前最流行的服务网格实现之一，通过透明地插入代理（sidecar）实现对服务间通信的管理，为应用开发者和运维人员提供了一套统一的流量治理、安全策略和可观察性解决方案。\nIstio 的架构主要分为数据平面和控制平面两部分，各自承担不同的职责：\n数据平面：负责处理所有进入和离开服务的网络流量。 每个服务实例旁边都会部署一个 Envoy 代理。代理（sidecar）拦截所有进入和发出的网络流量，实现请求路由、流量管理、负载均衡、故障注入、超时重试等功能。 控制平面：负责集中管理和配置数据平面中的代理。 在最新版本的 Istio 中，许多传统的控制平面组件（如 Pilot、Citadel 和 Galley）已被整合为一个统一的组件 Istiod。功能： 向 Envoy sidecar 分发服务发现信息和路由规则。 统一管理安全策略，颁发和管理服务间的身份凭证（例如实现 mTLS 加密通信）。 处理配置验证和分发，实现策略和遥测数据的收集。 策略控制：基于请求属性（如 URL、HTTP 方法、请求头等）进行精细化流量管理和访问控制。 遥测和监控：Istio 能够自动采集请求延迟、成功率、错误率等指标，并将数据上报到 Prometheus 等监控系统，同时支持分布式追踪（如集成 Jaeger 或 Zipkin）。 要在 K8s 中部署 Istio 很简单，Istio 提供了自动注入 Envoy 代理到 Pod 的机制。用户只需在目标命名空间中启用自动注入标签，系统会自动为新创建的 Pod 注入 sidecar 容器。\nIstio 的优势：\n应用解耦：将流量管理、安全和监控逻辑从应用代码中分离出来，使开发者专注于业务逻辑。 灵活的流量控制：支持动态路由、流量镜像、熔断、重试等高级流量控制策略，有效提升服务稳定性。 增强安全性：通过自动化的身份管理和双向 TLS，加密服务间通信，降低安全风险。 丰富的可观察性：内置对遥测数据、日志和分布式追踪的支持，帮助运维人员快速定位和解决问题。 ","wordCount":"1376","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-01-25T00:00:00Z","dateModified":"2025-01-25T00:00:00Z","author":{"@type":"Person","name":"Kurong"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/dailydev/kubernetes%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"},"publisher":{"@type":"Organization","name":"KurongBlog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">《Kubernetes微服务实战》记录</h1><div class=post-meta><span title='2025-01-25 00:00:00 +0000 UTC'>January 25, 2025</span>&nbsp;·&nbsp;Kurong&nbsp;|&nbsp;<a href=https://github.com/KurongTohsaka/KurongTohsaka.github.io/content/posts/DailyDev/%e3%80%8aKubernetes%e5%be%ae%e6%9c%8d%e5%8a%a1%e5%ae%9e%e6%88%98%e3%80%8b%e8%ae%b0%e5%bd%95.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#面向开发人员的-kubernetes-简介>面向开发人员的 Kubernetes 简介</a><ul><li><a href=#部分核心概念>部分核心概念</a></li><li><a href=#kubernetes-架构>Kubernetes 架构</a></li><li><a href=#微服务的完美搭档>微服务的完美搭档</a></li></ul></li><li><a href=#使用-kubernetes-配置微服务>使用 Kubernetes 配置微服务</a><ul><li><a href=#使用-kubernetes-configmap>使用 Kubernetes ConfigMap</a></li><li><a href=#服务发现>服务发现</a></li></ul></li><li><a href=#kubernetes-与微服务安全>Kubernetes 与微服务安全</a><ul><li><a href=#用户账户和服务账户>用户账户和服务账户</a></li><li><a href=#使用-kubernetes-管理密钥>使用 Kubernetes 管理密钥</a></li></ul></li><li><a href=#api-与负载均衡器>API 与负载均衡器</a><ul><li><a href=#kubernetes-的服务>Kubernetes 的服务</a></li><li><a href=#东西流量和南北流量>东西流量和南北流量</a></li><li><a href=#ingress-和负载均衡器>ingress 和负载均衡器</a></li><li><a href=#通过消息队列发送和接收事件>通过消息队列发送和接收事件</a></li></ul></li><li><a href=#有状态服务>有状态服务</a><ul><li><a href=#抽象存储>抽象存储</a></li><li><a href=#使用-statefulset-在-kubernetes-集群内存储数据>使用 StatefulSet 在 Kubernetes 集群内存储数据</a></li><li><a href=#在-kubernetes-中使用关系型和非关系型数据库>在 Kubernetes 中使用关系型和非关系型数据库</a></li></ul></li><li><a href=#在-kubernetes-上运行-serverless-任务>在 Kubernetes 上运行 Serverless 任务</a><ul><li><a href=#云中的-serverless>云中的 Serverless</a></li><li><a href=#常见的-serverless-框架>常见的 Serverless 框架</a></li></ul></li><li><a href=#微服务的部署>微服务的部署</a><ul><li><a href=#部署对象>部署对象</a></li><li><a href=#多环境部署>多环境部署</a></li><li><a href=#高级部署策略>高级部署策略</a></li></ul></li><li><a href=#监控日志和指标>监控、日志和指标</a><ul><li><a href=#自愈机制>自愈机制</a></li><li><a href=#集群自动伸缩>集群自动伸缩</a></li><li><a href=#监控>监控</a></li><li><a href=#日志>日志</a></li><li><a href=#指标>指标</a></li></ul></li><li><a href=#服务网格与-istio>服务网格与 Istio</a><ul><li><a href=#服务网格>服务网格</a></li><li><a href=#istio>Istio</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=kubernetes微服务实战记录>《Kubernetes微服务实战》记录<a hidden class=anchor aria-hidden=true href=#kubernetes微服务实战记录>#</a></h1><h2 id=面向开发人员的-kubernetes-简介>面向开发人员的 Kubernetes 简介<a hidden class=anchor aria-hidden=true href=#面向开发人员的-kubernetes-简介>#</a></h2><h3 id=部分核心概念>部分核心概念<a hidden class=anchor aria-hidden=true href=#部分核心概念>#</a></h3><ul><li>Node：Node 是 Kubernetes 集群中的一个工作单元，表示集群中的一台物理机或虚拟机。Node 的作用是为运行容器化应用提供计算资源，一个 Node 可以运行多个 Pod。Node 分为：<ul><li>Master Node：负责集群的控制平面，管理所有工作节点。</li><li>Worker Node：运行实际的应用程序工作负载，实际上就是 Pod。</li></ul></li><li>Pod：Pod 是 Kubernetes 中最小的可部署单位，表示一个或多个容器的集合。有以下特性：<ul><li>Pod 内的容器共享一个 IP 地址，可以通过 <code>localhost</code> 相互通信。</li><li>Pod 内的容器可以共享挂载的存储卷（Volume）。</li><li>Pod 通常包含运行同一应用程序组件的容器，如主应用程序容器、日志采集容器等。</li></ul></li><li>Namespace：用于逻辑上隔离资源。可以在同一集群中运行多个项目或团队的工作负载。</li><li>Service：用于将一组 Pod 的访问暴露给外部或集群内部的其他 Pod。</li><li>Deployment：用于声明和管理 Pod 的期望状态，例如副本数、滚动更新等。</li><li>Volume：提供持久化存储，允许 Pod 重启后数据仍然保留。</li></ul><h3 id=kubernetes-架构>Kubernetes 架构<a hidden class=anchor aria-hidden=true href=#kubernetes-架构>#</a></h3><p>每个集群都有一个控制平面和数据平面，数据平面由多个节点组成，控制平面将在这些节点上部署并运行 Pod（容器组），监控变更并做出响应。</p><p>控制平面包含以下组件：</p><ul><li>API 服务器。</li><li>etcd 存储。</li><li>调度器：kube 调度器负责将 Pod 调度到工作节点。</li><li>控制器管理器：kube 控制器管理器是包含多个控制器的单个进程，这些控制器监控着集群事件和对集群的更改做出响应。<ul><li>节点控制器：负责在节点出现故障时进行通知和响应。</li><li>副本控制器：确保每个副本集（replica set）或副本控制器对象中有正确数量的 Pod 。</li><li>端点控制器：为每个服务分配一个列出该服务的 Pod 的端点对象。</li><li>服务账户和令牌控制器：使用默认服务账户和响应的 API 访问令牌对新的命名空间进行初始化。</li></ul></li></ul><p>数据平面是集群中将容器化工作负载转为 Pod 运行的节点的集合。</p><p>K8s 会在每个节点上安装一些组件以进行 Pod 的通信、监控和调度，包括：</p><ul><li>kublet ：是 K8s 的代理，负责与 API 服务器进行通信，并运行和管理在节点上的 Pod 。</li><li>kube proxy ：负责节点的网络连接，充当服务的本地前端，并且可以转发 TCP 和 UDP 数据包。它通过 DNS 或环境变量来发现服务的 IP 地址。</li><li>容器运行时：Docker、gRPC 。</li><li>kubectl ：命令行工具 CLI 。</li></ul><h3 id=微服务的完美搭档>微服务的完美搭档<a hidden class=anchor aria-hidden=true href=#微服务的完美搭档>#</a></h3><p>ReplicaSet 是具有一定数量副本的 Pod 集合，创建它时 K8s 会确保始终有指定数量的 Pod 在集群中运行。以下是一个 K8s 部署清单：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1 </span><span class=w> </span><span class=c># 用来标记 K8s 的资源版本</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment </span><span class=w> </span><span class=c># 指定处理的资源或 API 对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx </span><span class=w> </span><span class=c># 用来引用此特定资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>  </span><span class=c># 标签允许 K8s 对共享相同标签的一组资源进行操作</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>  </span><span class=c># Deployment 的规范</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>  </span><span class=c># 副本数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>  </span><span class=c># 选择器，管理具有与 matchLabels 匹配的标签的 Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>  </span><span class=c># Pod 模板</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>  </span><span class=c># Pod 的规范</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.15.4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>K8s 提供了 Service 服务资源，用于微服务的公开和发现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-service </span><span class=w> </span><span class=c># Service 名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>  </span><span class=c># 选择与 Deployment 中标签匹配的 Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>  </span><span class=c># Service 的端口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>  </span><span class=c># 映射到 Pod 的 containerPort</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ClusterIP </span><span class=w> </span><span class=c># Service 类型，默认为 ClusterIP</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>关于微服务安全，K8s 有以下措施：</p><ul><li>通过命名空间将集群的不同部分相互隔离。</li><li>服务账户和权限。</li><li>密钥管理。</li><li>利用客户端证书对任何外部通信进行双重认证，如 HTTPS。</li><li>通过网络策略，定义和调整集群中的网络流量和访问。</li></ul><p>使用 K8s 扩展微服务有两种方式，这两个方式都可以通过更新部署的副本数显式扩展微服务：</p><ul><li>扩展 Pod 的数量。</li><li>扩展集群的总容量。</li></ul><p>同时，K8s 可以对 Pod、资源等进行监控，日志也实现了集中管理。</p><h2 id=使用-kubernetes-配置微服务>使用 Kubernetes 配置微服务<a hidden class=anchor aria-hidden=true href=#使用-kubernetes-配置微服务>#</a></h2><h3 id=使用-kubernetes-configmap>使用 Kubernetes ConfigMap<a hidden class=anchor aria-hidden=true href=#使用-kubernetes-configmap>#</a></h3><p>ConfigMap 是用于存储非机密配置信息的资源对象，它通常用来管理应用程序所需的配置数据。大概形式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>ConfigMap</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>data</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>config1</span><span class=p>:</span><span class=w> </span><span class=l>value1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>config2</span><span class=p>:</span><span class=w> </span><span class=l>value2</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>要想让 Pod 使用 ConfigMap 则有三种使用方式：</p><ul><li><p>作为环境变量：将 ConfigMap 中的值注入到容器的环境变量中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>CONFIG1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>valueFrom</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>configMapKeyRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>config1</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>挂载为文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>config-volume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>configMap</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/etc/config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>config-volume</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>作为命令行参数。</p></li></ul><p>使用 ConfigMap 可以实现配置动态更新，而且使配置易于管理。</p><h3 id=服务发现>服务发现<a hidden class=anchor aria-hidden=true href=#服务发现>#</a></h3><p>K8s 内置了服务发现功能，无需做其他工作。每个服务都有一个端点资源，K8s 会使这个端点与运行该服务的容器地址保持同步。注意，每个 Pod 都有自己的 IP 地址，只有 API 服务器具有公共 IP 地址。每个服务都通过 DNS 和环境变量自动公开给集群中的其他服务：</p><ul><li>DNS：K8s 默认会使用 CoreDNS 提供内部的 DNS 服务，所有 Service 都会被注册到集群的 DNS 系统中，从而可以通过域名进行访问。DNS 是动态的，能够实时解析 Service 的 ClusterIP，因此即使 Service 的后端 Pod 实例发生变化（如扩缩容），DNS 解析仍然有效。</li><li>环境变量：当一个 Pod 被创建时，K8s 会将集群中每个 Service 的相关信息（例如 IP 和端口）注入到 Pod 的环境变量中。环境变量是静态的，仅在 Pod 创建时生成，因此如果 Service 的 IP 发生变化（例如重建），需要重启 Pod 才能更新环境变量。</li></ul><h2 id=kubernetes-与微服务安全>Kubernetes 与微服务安全<a hidden class=anchor aria-hidden=true href=#kubernetes-与微服务安全>#</a></h2><h3 id=用户账户和服务账户>用户账户和服务账户<a hidden class=anchor aria-hidden=true href=#用户账户和服务账户>#</a></h3><p>用户账户代表人类用户（管理员、开发者等），是外部用户与 K8s API 的交互身份。K8s 不直接创建或管理用户账户的生命周期，通常需要集成外部认证系统。</p><p>服务账户用于代表运行在集群中的应用程序或 Pod，是 Pod 与K8s API 的交互身份。默认情况下，每个命名空间都会有一个名为 <code>default</code> 的服务账户，Pod 没有指定服务账户时会自动绑定到这个默认账户。服务账户通过挂载到 Pod 的服务账户 Token 来认证自己。而且服务账户是命名空间作用域的，不能跨命名空间使用。</p><h3 id=使用-kubernetes-管理密钥>使用 Kubernetes 管理密钥<a hidden class=anchor aria-hidden=true href=#使用-kubernetes-管理密钥>#</a></h3><p>K8s 中的密钥通常有三种：</p><ul><li>服务账户的 API Token 。</li><li>私有镜像仓库密钥。</li><li>Opaque 密钥，这是 K8s 不知道的密钥，可以将敏感信息存储在这里。它提供了一个安全的密钥存储库，以及管理密钥的 API 。</li></ul><p>在使用密钥时，可以将密钥打包到容器里、存储到环境变量、挂载为文件。</p><h2 id=api-与负载均衡器>API 与负载均衡器<a hidden class=anchor aria-hidden=true href=#api-与负载均衡器>#</a></h2><h3 id=kubernetes-的服务>Kubernetes 的服务<a hidden class=anchor aria-hidden=true href=#kubernetes-的服务>#</a></h3><p>K8s 的服务必须属于下面的某种类型：</p><ul><li>ClusterIP（默认值）：只能在集群内访问该服务，这是和微服务之间相互通信。</li><li>NodePort：该服务通过所有节点上的专用端口对外开放。当请求通过专用 NodePort 进入节点时，kubelet 将负责将其转发到 Pod 所在节点。</li><li>LoadBalancer：当 K8s 集群运行在提供负载均衡器支持的云平台上时，该类服务较常见。</li><li>ExternalName：该类服务将对服务的请求解析为外部提供的 DNS 名称。</li></ul><h3 id=东西流量和南北流量>东西流量和南北流量<a hidden class=anchor aria-hidden=true href=#东西流量和南北流量>#</a></h3><p>东西流量指服务/Pod/容器在集群内的相互通信。南北流量指对外公开服务的通信。</p><h3 id=ingress-和负载均衡器>ingress 和负载均衡器<a hidden class=anchor aria-hidden=true href=#ingress-和负载均衡器>#</a></h3><p>关于 ingress ：</p><ul><li>ingress 是 K8s 中的一种资源对象，用于管理外部 HTTP/HTTPS 流量如何访问集群内部的服务。</li><li>ingress 可以定义域名的路由规则、支持 TLS/HTTPS 加密、提供统一入口来管理多个服务。</li><li>ingress 由 ingress 控制器和 ingress 资源组成。前者处理 ingress 规则的实现，后者为用户定义的规则和配置。</li></ul><p>关于负载均衡器：</p><ul><li>负载均衡器通常指将流量分发给多个 Pod 的机制，分为内部负载均衡和外部负载均衡。</li><li>内部负载均衡：<ul><li>K8s 的 Service 对象自带负载均衡功能。</li><li>Service 的 <code>ClusterIP</code> 会在集群内部均衡流量到不同的 Pod。</li></ul></li><li>外部负载均衡：<ul><li>在云环境中，Service 的类型设置为 <code>LoadBalancer</code> 时，会创建一个云提供商的负载均衡器（如 AWS ELB、GCP Load Balancer）。</li><li>通过负载均衡器将外部流量引入到 K8s 服务中。</li></ul></li></ul><h3 id=通过消息队列发送和接收事件>通过消息队列发送和接收事件<a hidden class=anchor aria-hidden=true href=#通过消息队列发送和接收事件>#</a></h3><p>NATS 是一款高性能、轻量级的开源消息系统，广泛用于分布式系统和云原生应用中。这是一个 CNCF 项目，由 Go 实现。它采用发布-订阅（Pub/Sub）、请求-响应（Request-Reply）以及队列（Queue）通信模式，设计目标是简单、快速和可靠。</p><h2 id=有状态服务>有状态服务<a hidden class=anchor aria-hidden=true href=#有状态服务>#</a></h2><h3 id=抽象存储>抽象存储<a hidden class=anchor aria-hidden=true href=#抽象存储>#</a></h3><p>K8s 的存储模型包含以下几个概念：</p><ul><li><p>卷：是 K8s 中最基本的存储单元，用于为 Pod 提供持久化存储。</p></li><li><p>持久卷：是集群级别的存储资源，由管理员进行配置。</p></li><li><p>持久卷声明：是用户对存储资源的请求，类似于 Pod 对计算资源的请求。持久卷声明与持久卷绑定，Pod 通过持久卷声明使用持久卷。</p></li><li><p>存储类：用于动态创建持久卷，允许按需分配存储资源。每个存储类对应一种存储后端（如SSD、HDD），并定义了持久卷的属性（如卷类型、回收策略）。</p></li><li><p>动态供给：允许根据持久卷声明自动创建持久卷，无需管理员手动干预。</p></li><li><p>CSI（容器存储接口）：是 K8s 与存储插件之间的标准接口，允许第三方存储提供商集成。</p></li></ul><h3 id=使用-statefulset-在-kubernetes-集群内存储数据>使用 StatefulSet 在 Kubernetes 集群内存储数据<a hidden class=anchor aria-hidden=true href=#使用-statefulset-在-kubernetes-集群内存储数据>#</a></h3><p>StatefulSet 是K8s 中用于管理有状态应用的工作负载 API 对象。与 Deployment 不同，StatefulSet 为每个 Pod 提供唯一的标识和稳定的网络标识、持久化存储，确保 Pod 在重启、迁移或扩展时保持一致性。StatefulSet 适用于需要稳定网络标识、有序部署和持久化存储的应用，如数据库（MySQL、PostgreSQL）、分布式系统（Zookeeper、Kafka）等。</p><p>StatefulSet 有一些核心特性：</p><ul><li>稳定的网络标识：每个 Pod 都有一个唯一的、稳定的网络标识（如 <code>pod-name-0</code>, <code>pod-name-1</code>），即使 Pod 被重新调度，其名称和网络标识也不会改变。</li><li>有序部署和扩展：Pod 的创建和扩展是按顺序进行的。</li><li>有序终止和缩容：Pod 的删除是按逆序进行的。</li><li>持久化存储：每个 Pod 可以绑定一个独立的持久卷，确保数据在 Pod 重启或迁移时不会丢失。</li><li>稳定存储：通过配置，StatefulSet 可以为每个 Pod 动态的创建持久卷声明。</li></ul><p>StatefulSet 通常与 Headless Service 使用。Headless Service 不会分配 ClusterIP，而是直接返回 Pod 的 IP 和 DNS 记录。</p><p>下面是一个 StatefulSet 配置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>StatefulSet</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>serviceName</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;nginx&#34;</span><span class=w>  </span><span class=c># 关联的 Headless Service 名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>           </span><span class=c># Pod 副本数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx       </span><span class=w> </span><span class=c># 匹配 Pod 的标签</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx     </span><span class=w> </span><span class=c># Pod 的标签</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>www     </span><span class=w> </span><span class=c># 挂载的卷名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/usr/share/nginx/html</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumeClaimTemplates</span><span class=p>:</span><span class=w>  </span><span class=c># 动态创建 PVC</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>www         </span><span class=w> </span><span class=c># PVC 名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>accessModes</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=w> </span><span class=s2>&#34;ReadWriteOnce&#34;</span><span class=w> </span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>1Gi  </span><span class=w> </span><span class=c># 存储大小</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=在-kubernetes-中使用关系型和非关系型数据库>在 Kubernetes 中使用关系型和非关系型数据库<a hidden class=anchor aria-hidden=true href=#在-kubernetes-中使用关系型和非关系型数据库>#</a></h3><p>使用 StatefulSet 部署 MySQL：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span><span class=lnt id=hl-6-32><a class=lnlinks href=#hl-6-32>32</a>
</span><span class=lnt id=hl-6-33><a class=lnlinks href=#hl-6-33>33</a>
</span><span class=lnt id=hl-6-34><a class=lnlinks href=#hl-6-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>StatefulSet</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>serviceName</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;mysql&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>mysql:5.7</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>MYSQL_ROOT_PASSWORD</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;password&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>3306</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql-data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/var/lib/mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumeClaimTemplates</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql-data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>accessModes</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=w> </span><span class=s2>&#34;ReadWriteOnce&#34;</span><span class=w> </span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>10Gi</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>使用 StatefulSet 部署 Redis：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>StatefulSet</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>serviceName</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;redis&#34;</span><span class=w>  </span><span class=c># 关联的 Headless Service 名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>           </span><span class=c># Redis 实例数量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>redis        </span><span class=w> </span><span class=c># 匹配 Pod 的标签</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>redis      </span><span class=w> </span><span class=c># Pod 的标签</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>redis:6.2 </span><span class=w> </span><span class=c># Redis 镜像</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>6379</span><span class=w>  </span><span class=c># Redis 默认端口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis-data    </span><span class=w> </span><span class=c># 挂载的卷名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/data    </span><span class=w> </span><span class=c># Redis 数据目录</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumeClaimTemplates</span><span class=p>:</span><span class=w>        </span><span class=c># 动态创建 PVC</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis-data        </span><span class=w> </span><span class=c># PVC 名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>accessModes</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=w> </span><span class=s2>&#34;ReadWriteOnce&#34;</span><span class=w> </span><span class=p>]</span><span class=w>  </span><span class=c># 访问模式</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>1Gi        </span><span class=w> </span><span class=c># 存储大小</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这是 Redis 的 Headless Service 配置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>clusterIP</span><span class=p>:</span><span class=w> </span><span class=l>None </span><span class=w> </span><span class=c># Headless Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>6379</span><span class=w>     </span><span class=c># Redis 默认端口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>redis    </span><span class=w> </span><span class=c># 匹配 StatefulSet 的 Pod 标签</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=在-kubernetes-上运行-serverless-任务>在 Kubernetes 上运行 Serverless 任务<a hidden class=anchor aria-hidden=true href=#在-kubernetes-上运行-serverless-任务>#</a></h2><h3 id=云中的-serverless>云中的 Serverless<a hidden class=anchor aria-hidden=true href=#云中的-serverless>#</a></h3><p>Serverless（无服务器）是一种云计算模式，在这种模式下，开发者不需要管理服务器或底层基础设施，而是专注于业务代码的编写。所有的基础资源（计算、存储、网络等）由云服务提供商自动管理和调度。</p><p>在 Serverless 模式中，应用被拆分为一个个独立的函数（即“函数即服务”，FaaS），每个函数只在特定事件触发时运行。云平台会根据请求的数量动态分配资源，并根据实际运行时间收费。例如，当一个 HTTP 请求触发一个函数时，该函数就会被加载、执行，并在完成后自动销毁，用户只需为这段实际运行的时间付费。</p><p>Serverless的优缺点：</p><ul><li>优势：<ul><li>降低运维复杂度，开发者可专注于业务逻辑。</li><li>经济高效，按需计费模式避免资源浪费。</li><li>弹性扩展，能够快速应对流量变化。</li></ul></li><li>局限：<ul><li>冷启动问题：长时间不调用的函数可能存在首次调用延迟。</li><li>依赖云服务商：可能会受到厂商锁定（vendor lock-in）的影响。</li><li>调试和监控较为复杂：由于执行环境由云平台管理，本地调试和日志追踪可能不如传统服务直观。</li></ul></li></ul><h3 id=常见的-serverless-框架>常见的 Serverless 框架<a hidden class=anchor aria-hidden=true href=#常见的-serverless-框架>#</a></h3><ul><li>Nuclio：一个知名的 Serverless 平台，支持高性能、低延迟的函数执行。</li><li>Knative：由 Google 等公司主导开发，Knative 提供了构建、部署和管理 Serverless 应用的完整解决方案。与 Kubernetes 深度集成，支持蓝绿部署、滚动更新和无缝扩展，适用于构建大规模、云原生的 Serverless 应用。</li><li>Kubeless：Kubeless 是一个原生 K8s 的 Serverless 框架，允许用户以 YAML 文件的形式直接部署函数。适合中小型应用或实验性项目，快速上手部署简单的函数服务。</li><li>OpenFaaS：OpenFaaS（Functions as a Service）通过 Docker 容器化的方式来封装函数，提供了简洁的 UI 和 CLI 工具。适用于混合云和多云环境中快速构建和部署 Serverless 应用。</li><li>Fission：Fission 是一个专为 K8s 设计的 Serverless 框架，以低延迟和高性能著称。适合对响应速度有较高要求的业务场景，能够高效处理大量短时间任务。</li></ul><h2 id=微服务的部署>微服务的部署<a hidden class=anchor aria-hidden=true href=#微服务的部署>#</a></h2><h3 id=部署对象>部署对象<a hidden class=anchor aria-hidden=true href=#部署对象>#</a></h3><ul><li>Depolyment：Deployment 是最常用的部署对象，主要用于管理无状态（Stateless）的应用。它定义了 Pod 模板、期望副本数、更新策略等，并通过管理底层的 ReplicaSet 实现 Pod 的创建、扩缩容和滚动升级。</li><li>StatefulSet：用于管理有状态（Stateful）的应用，如数据库或分布式存储系统。它提供了稳定的网络标识、持久化存储绑定以及有序的启动和终止顺序。</li><li>DaemonSet：保证集群中每个（或指定一部分）节点上都运行一个 Pod。常用于部署日志收集、监控代理、安全扫描等守护进程。</li><li>ReplicaSet：用于保证一组 Pod 始终保持在指定的副本数量。通常由 Deployment 控制，不需要直接创建，但在一些场景下也可以单独使用。</li></ul><h3 id=多环境部署>多环境部署<a hidden class=anchor aria-hidden=true href=#多环境部署>#</a></h3><p>在实际开发和运维过程中，通常需要在不同的环境（如开发、测试、预发布、生产）中部署应用。多环境部署主要关注环境隔离、配置管理和自动化流程等问题。</p><ul><li>NameSpace 隔离：K8s 中的 Namespace 用于逻辑隔离资源。不同环境可以分配不同的 Namespace，如 <code>dev</code>、<code>staging</code>、<code>prod</code>。这不仅便于资源管理，还能设置不同的资源配额和权限控制策略。</li><li>配置管理：利用 ConfigMap 管理非敏感配置信息，利用 Secret 管理敏感信息。不同环境下的配置可以通过不同的 ConfigMap/Secret 来区分，再通过环境变量或挂载文件的方式传递给 Pod。或者部署时可利用 YAML 文件中 <code>env</code> 字段注入环境变量，或使用 <code>args</code>/<code>command</code> 自定义启动参数，实现同一镜像在不同环境下的不同行为。</li><li>Helm：Helm 是 K8s 的包管理工具，通过 Chart 定义应用的各种资源。借助 Helm，可以使用同一个 Chart 针对不同环境传入不同的 values 参数，实现配置复用与环境定制化部署。</li><li>CI/CD：通过 CI/CD 工具（如 Jenkins、GitLab CI、Argo CD 等）实现代码构建、镜像打包、自动测试以及自动部署。流水线中可设置不同的分支对应不同环境，并在每次提交后自动触发相应环境的部署更新。利用 CI/CD 流水线自动化部署的同时，可以记录每次部署的版本信息，结合 K8s 自身的回滚能力，实现快速恢复和版本切换。</li></ul><h3 id=高级部署策略>高级部署策略<a hidden class=anchor aria-hidden=true href=#高级部署策略>#</a></h3><ul><li>滚动更新：滚动更新是一种渐进式更新策略，通过逐步替换旧版 Pod 为新版 Pod 来实现应用升级，确保在整个过程中服务始终可用。<ul><li>无需中断服务，更新过程透明。</li><li>可以根据流量情况和节点容量动态控制更新速率。</li></ul></li><li>蓝绿部署：蓝绿部署将旧版本（蓝）与新版本（绿）完全隔离部署在不同的环境中，通过切换流量路由实现版本切换。通常利用外部负载均衡器（或 Ingress 控制器）进行流量切换。<ul><li>可快速回滚，降低风险。</li><li>测试与验证环境独立，不影响现有业务。</li></ul></li><li>金丝雀发布：金丝雀发布是指将新版本部署到少量 Pod 上，先让少部分流量进入新版本以验证稳定性，再逐步扩大新版本的流量比例，最终完全替换旧版本。<ul><li>降低新版本升级风险。</li><li>在实际流量中验证新版本的性能和稳定性，及时发现潜在问题。</li></ul></li><li>A/B 测试和灰度发布：A/B 测试指在相同的生产环境中，同时部署两个或多个版本，通过不同用户组的反馈和数据对比，选择最优方案。类似于金丝雀发布，但灰度发布往往针对特定用户或特定条件进行版本切换，既可以逐步扩大流量，也可以根据用户特征精细控制版本分布。</li></ul><h2 id=监控日志和指标>监控、日志和指标<a hidden class=anchor aria-hidden=true href=#监控日志和指标>#</a></h2><h3 id=自愈机制>自愈机制<a hidden class=anchor aria-hidden=true href=#自愈机制>#</a></h3><p>自愈是 K8s 集群中一个核心特性，指的是集群能够在发生故障或异常时，自动将实际状态恢复到期望状态，保证系统持续可用。主要体现在以下几个方面：</p><ul><li><p>控制器自愈</p><ul><li>Deployment、ReplicaSet 和 StatefulSet 控制器：<ul><li>声明式管理：通过定义期望状态，K8s 控制器会不断对比实际状态，如发现 Pod 崩溃、失联或数量不足时，自动重启或创建新的 Pod。</li><li>滚动升级和回滚：在更新过程中，如果发现新版本出现问题，可以自动回滚到稳定版本，保证服务不中断。</li></ul></li></ul></li><li><p>健康检查（Liveness & Readiness Probes）</p><ul><li><p>Liveness Probe：</p><ul><li>作用：检测应用是否处于健康状态，如发现故障则重启容器。</li><li>实现：通过 HTTP 请求、TCP 检查或执行命令来判断容器状态。</li></ul></li><li><p>Readiness Probe：</p><ul><li>作用：判断容器是否已经准备好接收流量，避免在启动或更新过程中将流量导入未就绪的容器。</li></ul></li></ul></li><li><p>自动重调度与节点自愈</p><ul><li><p>节点状态监控：K8s 的 Node Controller 会定期检测节点的健康状态，一旦发现节点失联或状态异常，会将该节点标记为不可用，并将其上运行的 Pod 调度到其他健康节点上。</p></li><li><p>Pod 重启策略：若容器因内部错误退出，Pod 会按照重启策略（如 Always、OnFailure、Never）自动进行重启，确保服务恢复。</p></li></ul></li></ul><h3 id=集群自动伸缩>集群自动伸缩<a hidden class=anchor aria-hidden=true href=#集群自动伸缩>#</a></h3><p>集群自动伸缩（Autoscaling）是提高资源利用率和降低成本的重要手段，主要分为 Pod 级别的自动伸缩和节点级别的自动伸缩。</p><ul><li><p>Pod 级别自动伸缩</p><ul><li><p>Horizontal Pod Autoscaler (HPA)</p><ul><li><p>作用：根据应用实际的 CPU、内存或者自定义指标，对 Deployment、ReplicaSet、StatefulSet 中的 Pod 数量进行动态调整。</p></li><li><p>工作原理：</p><ul><li>HPA 定期查询指定指标数据（通常由 Prometheus Adapter 或 Metrics Server 提供），与设定的目标值比较。</li><li>若指标超出目标范围，则按比例增加 Pod 副本；若指标低于目标范围，则减少 Pod 数量。</li></ul></li></ul></li><li><p>Vertical Pod Autoscaler (VPA)</p><ul><li><p>作用：根据 Pod 的资源使用情况，自动调整容器的 CPU 和内存请求与限制，帮助在固定 Pod 数量下优化资源分配。</p></li><li><p>特点：</p><ul><li>适用于难以通过增加副本解决资源瓶颈的场景。<ul><li>配置和调整相对复杂，可能需要重启 Pod 生效。</li></ul></li></ul></li></ul></li></ul></li><li><p>节点级别自动伸缩</p><ul><li><p>Cluster Autoscaler</p><ul><li><p>作用：针对托管在云平台上的 K8s 集群（如 AWS EKS、GKE、AKS 等），当集群内资源不足（无法调度新 Pod）时，自动增加节点；当节点长期处于低负载、空闲状态时，自动缩减节点数，降低成本。</p></li><li><p>工作原理：</p><ul><li>持续监控调度器的排队情况和节点资源利用率。</li><li>在 Pod 无法调度时，向云平台 API 请求增加节点；在节点空闲且 Pod 可迁移时，安全驱逐并缩减节点数。</li></ul></li></ul></li></ul></li></ul><h3 id=监控>监控<a hidden class=anchor aria-hidden=true href=#监控>#</a></h3><p>主要组件和工具：</p><ul><li>Prometheus：<ul><li>作用：开源监控系统和时序数据库，专门用于抓取、存储和查询各种指标数据。</li><li>采集方式：通过 HTTP Pull 模式定时抓取目标暴露的指标（通常为 <code>/metrics</code> 接口）。</li></ul></li><li>Grafana：<ul><li>作用：数据可视化工具，可以与 Prometheus 等时序数据库配合，通过仪表板展示实时和历史指标数据。</li><li>功能：支持自定义告警规则、报表制作和数据关联分析，帮助运维人员直观地监控集群运行情况。</li></ul></li><li>Alertmanager：<ul><li>作用：与 Prometheus 配合使用，实现告警信息的分组、抑制和路由。</li><li>告警渠道：支持邮件、Slack、PagerDuty 等多种告警方式，便于及时通知相关人员。</li></ul></li></ul><h3 id=日志>日志<a hidden class=anchor aria-hidden=true href=#日志>#</a></h3><p>日志采集方式：</p><ul><li>容器标准输出：K8s 中容器的日志一般输出到标准输出（stdout）和标准错误（stderr），由 kubelet 写入宿主机上的日志文件（通常在 <code>/var/log/containers</code>）。</li><li>DaemonSet 日志采集器：在每个节点上部署日志采集代理（如 Fluentd、Filebeat 或 Logstash），以 DaemonSet 的方式运行，保证所有节点的日志能够被采集并转发到集中式日志存储系统中。</li></ul><p>常见日志系统：</p><ul><li>ELK/EFK Stack：<ul><li>Elasticsearch：日志存储和检索引擎，可以存储海量日志数据，并支持高效查询。</li><li>Logstash/Fluentd：日志采集和处理工具，负责解析、过滤并将日志数据传输到 Elasticsearch。</li><li>Kibana：数据可视化和分析工具，通过图形化界面帮助运维人员快速定位问题。</li></ul></li><li>Loki + Promtail + Grafana：<ul><li>Loki：由 Grafana Labs 开发的日志聚合系统，专门设计用于与 Prometheus 数据模型兼容，并与 Grafana 紧密集成。</li><li>Promtail：日志采集器，类似于 Fluentd，但与 Loki 集成更紧密。</li></ul></li></ul><h3 id=指标>指标<a hidden class=anchor aria-hidden=true href=#指标>#</a></h3><ul><li>自定义指标：利用 Prometheus Client 库（如 Prometheus Python Client、Java Client 等）在应用中嵌入指标采集功能，暴露 HTTP 接口供 Prometheus 抓取。</li><li>Kubernetes 内置指标：如 cAdvisor 提供容器级别的资源使用情况，kube-state-metrics 提供集群状态信息。</li><li>展示与告警：利用 Grafana 等工具构建仪表板，并设置阈值告警，确保在关键指标异常时能迅速通知运维人员。</li></ul><h2 id=服务网格与-istio>服务网格与 Istio<a hidden class=anchor aria-hidden=true href=#服务网格与-istio>#</a></h2><h3 id=服务网格>服务网格<a hidden class=anchor aria-hidden=true href=#服务网格>#</a></h3><p>随着微服务架构的普及，单个应用被拆分为众多独立服务，各服务之间通信频繁且复杂，传统的点对点通信往往需要在每个服务中自行实现流量管理、重试、熔断、认证等功能，导致代码重复、运维困难。服务网格正是为了解决这些问题而诞生的。</p><p>服务网格是一种专门用于管理微服务之间通信的基础设施层，它将服务间的网络通信抽象出来，形成一层独立于业务逻辑之外的透明代理层。通过这种方式，开发者可以将流量路由、负载均衡、故障恢复、安全认证、监控等能力从应用代码中分离出来，由网格层统一管理。</p><h3 id=istio>Istio<a hidden class=anchor aria-hidden=true href=#istio>#</a></h3><p>Istio 作为目前最流行的服务网格实现之一，通过透明地插入代理（sidecar）实现对服务间通信的管理，为应用开发者和运维人员提供了一套统一的流量治理、安全策略和可观察性解决方案。</p><p>Istio 的架构主要分为数据平面和控制平面两部分，各自承担不同的职责：</p><ul><li>数据平面：负责处理所有进入和离开服务的网络流量。<ul><li>每个服务实例旁边都会部署一个 Envoy 代理。代理（sidecar）拦截所有进入和发出的网络流量，实现请求路由、流量管理、负载均衡、故障注入、超时重试等功能。</li></ul></li><li>控制平面：负责集中管理和配置数据平面中的代理。<ul><li>在最新版本的 Istio 中，许多传统的控制平面组件（如 Pilot、Citadel 和 Galley）已被整合为一个统一的组件 Istiod。功能：<ul><li>向 Envoy sidecar 分发服务发现信息和路由规则。</li><li>统一管理安全策略，颁发和管理服务间的身份凭证（例如实现 mTLS 加密通信）。</li><li>处理配置验证和分发，实现策略和遥测数据的收集。</li></ul></li><li>策略控制：基于请求属性（如 URL、HTTP 方法、请求头等）进行精细化流量管理和访问控制。</li><li>遥测和监控：Istio 能够自动采集请求延迟、成功率、错误率等指标，并将数据上报到 Prometheus 等监控系统，同时支持分布式追踪（如集成 Jaeger 或 Zipkin）。</li></ul></li></ul><p>要在 K8s 中部署 Istio 很简单，Istio 提供了自动注入 Envoy 代理到 Pod 的机制。用户只需在目标命名空间中启用自动注入标签，系统会自动为新创建的 Pod 注入 sidecar 容器。</p><p>Istio 的优势：</p><ul><li>应用解耦：将流量管理、安全和监控逻辑从应用代码中分离出来，使开发者专注于业务逻辑。</li><li>灵活的流量控制：支持动态路由、流量镜像、熔断、重试等高级流量控制策略，有效提升服务稳定性。</li><li>增强安全性：通过自动化的身份管理和双向 TLS，加密服务间通信，降低安全风险。</li><li>丰富的可观察性：内置对遥测数据、日志和分布式追踪的支持，帮助运维人员快速定位和解决问题。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></li><li><a href=http://localhost:1313/tags/kubernetes/>Kubernetes</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/dailydev/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95/><span class=title>« Prev</span><br><span>《数据密集型系统设计》记录</span>
</a><a class=next href=http://localhost:1313/posts/dailydev/minikubeubuntu%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E9%9B%86%E7%BE%A4%E8%B8%A9%E5%9D%91/><span class=title>Next »</span><br><span>minikube：Ubuntu部署本地集群踩坑</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>KurongBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>