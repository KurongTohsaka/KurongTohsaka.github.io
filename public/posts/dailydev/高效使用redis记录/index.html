<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《高效使用Redis》记录 | KurongBlog</title>
<meta name=keywords content="Redis"><meta name=description content="《高效使用Redis》记录
基础数据结构解析
对象
Redis中的 RedisObject 的 c 定义：


1
2
3
4
5
6
7
8


#define LRU_BITS 24
typedef struct redisObject {
  unsigned type:4;  // 数据类型
  unsigned encoding:4;  // 底层数据结构
  unsigned lru:LRU_BITS;  // 缓存淘汰时使用
  int refcount;  // 引用计数
  void *ptr;  // 指向实际存储位置
} robj;


RedisObject 是 Redis 中数据结构的一个抽象，用它来存储所有的 key-value 数据。
下面是结构体中各个属性的。说明：


type：用来表示对象类型；


encoding：表示当前对象底层存储所采用的数据结构，如int、字典、压缩列表、跳跃表等等；


lru：用于在配置文件中通过 maxmemory-policy 配置已用内存到最大内存限制时的缓存淘汰策略。


以 GET 命令为例，简单看看 Redis 中的 LRU 实现。使用 GET 后，会执行这段代码更新对象的 lru 属性：


1
2
3
4
5


if (server.maxmemory_policy & MAXMEMORY_FLAG_LRU) {
  uodateLFU(val);
} else {
  val->lru = LRU_CLOCK();
}


LRU_CLOCK 用于获取当前时间，但并不是实时获取。Redis 每 1s 执行系统调用来获取精确时间，然后存储在全局变量 server.lruclock 中，LRU_CLOCK 只是获取该缓存时间。updateLFU 用于更新对象的上次访问时间和访问次数。"><meta name=author content="Kurong"><link rel=canonical href=http://localhost:1313/posts/dailydev/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8redis%E8%AE%B0%E5%BD%95/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/dailydev/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8redis%E8%AE%B0%E5%BD%95/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><meta property="og:title" content="《高效使用Redis》记录"><meta property="og:description" content="《高效使用Redis》记录
基础数据结构解析
对象
Redis中的 RedisObject 的 c 定义：


1
2
3
4
5
6
7
8


#define LRU_BITS 24
typedef struct redisObject {
  unsigned type:4;  // 数据类型
  unsigned encoding:4;  // 底层数据结构
  unsigned lru:LRU_BITS;  // 缓存淘汰时使用
  int refcount;  // 引用计数
  void *ptr;  // 指向实际存储位置
} robj;


RedisObject 是 Redis 中数据结构的一个抽象，用它来存储所有的 key-value 数据。
下面是结构体中各个属性的。说明：


type：用来表示对象类型；


encoding：表示当前对象底层存储所采用的数据结构，如int、字典、压缩列表、跳跃表等等；


lru：用于在配置文件中通过 maxmemory-policy 配置已用内存到最大内存限制时的缓存淘汰策略。


以 GET 命令为例，简单看看 Redis 中的 LRU 实现。使用 GET 后，会执行这段代码更新对象的 lru 属性：


1
2
3
4
5


if (server.maxmemory_policy & MAXMEMORY_FLAG_LRU) {
  uodateLFU(val);
} else {
  val->lru = LRU_CLOCK();
}


LRU_CLOCK 用于获取当前时间，但并不是实时获取。Redis 每 1s 执行系统调用来获取精确时间，然后存储在全局变量 server.lruclock 中，LRU_CLOCK 只是获取该缓存时间。updateLFU 用于更新对象的上次访问时间和访问次数。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/dailydev/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8redis%E8%AE%B0%E5%BD%95/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-05T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-05T00:00:00+00:00"><meta property="og:site_name" content="KurongBlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="《高效使用Redis》记录"><meta name=twitter:description content="《高效使用Redis》记录
基础数据结构解析
对象
Redis中的 RedisObject 的 c 定义：


1
2
3
4
5
6
7
8


#define LRU_BITS 24
typedef struct redisObject {
  unsigned type:4;  // 数据类型
  unsigned encoding:4;  // 底层数据结构
  unsigned lru:LRU_BITS;  // 缓存淘汰时使用
  int refcount;  // 引用计数
  void *ptr;  // 指向实际存储位置
} robj;


RedisObject 是 Redis 中数据结构的一个抽象，用它来存储所有的 key-value 数据。
下面是结构体中各个属性的。说明：


type：用来表示对象类型；


encoding：表示当前对象底层存储所采用的数据结构，如int、字典、压缩列表、跳跃表等等；


lru：用于在配置文件中通过 maxmemory-policy 配置已用内存到最大内存限制时的缓存淘汰策略。


以 GET 命令为例，简单看看 Redis 中的 LRU 实现。使用 GET 后，会执行这段代码更新对象的 lru 属性：


1
2
3
4
5


if (server.maxmemory_policy & MAXMEMORY_FLAG_LRU) {
  uodateLFU(val);
} else {
  val->lru = LRU_CLOCK();
}


LRU_CLOCK 用于获取当前时间，但并不是实时获取。Redis 每 1s 执行系统调用来获取精确时间，然后存储在全局变量 server.lruclock 中，LRU_CLOCK 只是获取该缓存时间。updateLFU 用于更新对象的上次访问时间和访问次数。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"《高效使用Redis》记录","item":"http://localhost:1313/posts/dailydev/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8redis%E8%AE%B0%E5%BD%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《高效使用Redis》记录","name":"《高效使用Redis》记录","description":"《高效使用Redis》记录 基础数据结构解析 对象 Redis中的 RedisObject 的 c 定义：\n1 2 3 4 5 6 7 8 #define LRU_BITS 24 typedef struct redisObject { unsigned type:4; // 数据类型 unsigned encoding:4; // 底层数据结构 unsigned lru:LRU_BITS; // 缓存淘汰时使用 int refcount; // 引用计数 void *ptr; // 指向实际存储位置 } robj; RedisObject 是 Redis 中数据结构的一个抽象，用它来存储所有的 key-value 数据。\n下面是结构体中各个属性的。说明：\ntype：用来表示对象类型；\nencoding：表示当前对象底层存储所采用的数据结构，如int、字典、压缩列表、跳跃表等等；\nlru：用于在配置文件中通过 maxmemory-policy 配置已用内存到最大内存限制时的缓存淘汰策略。\n以 GET 命令为例，简单看看 Redis 中的 LRU 实现。使用 GET 后，会执行这段代码更新对象的 lru 属性：\n1 2 3 4 5 if (server.maxmemory_policy \u0026amp; MAXMEMORY_FLAG_LRU) { uodateLFU(val); } else { val-\u0026gt;lru = LRU_CLOCK(); } LRU_CLOCK 用于获取当前时间，但并不是实时获取。Redis 每 1s 执行系统调用来获取精确时间，然后存储在全局变量 server.lruclock 中，LRU_CLOCK 只是获取该缓存时间。updateLFU 用于更新对象的上次访问时间和访问次数。\n","keywords":["Redis"],"articleBody":"《高效使用Redis》记录 基础数据结构解析 对象 Redis中的 RedisObject 的 c 定义：\n1 2 3 4 5 6 7 8 #define LRU_BITS 24 typedef struct redisObject { unsigned type:4; // 数据类型 unsigned encoding:4; // 底层数据结构 unsigned lru:LRU_BITS; // 缓存淘汰时使用 int refcount; // 引用计数 void *ptr; // 指向实际存储位置 } robj; RedisObject 是 Redis 中数据结构的一个抽象，用它来存储所有的 key-value 数据。\n下面是结构体中各个属性的。说明：\ntype：用来表示对象类型；\nencoding：表示当前对象底层存储所采用的数据结构，如int、字典、压缩列表、跳跃表等等；\nlru：用于在配置文件中通过 maxmemory-policy 配置已用内存到最大内存限制时的缓存淘汰策略。\n以 GET 命令为例，简单看看 Redis 中的 LRU 实现。使用 GET 后，会执行这段代码更新对象的 lru 属性：\n1 2 3 4 5 if (server.maxmemory_policy \u0026 MAXMEMORY_FLAG_LRU) { uodateLFU(val); } else { val-\u003elru = LRU_CLOCK(); } LRU_CLOCK 用于获取当前时间，但并不是实时获取。Redis 每 1s 执行系统调用来获取精确时间，然后存储在全局变量 server.lruclock 中，LRU_CLOCK 只是获取该缓存时间。updateLFU 用于更新对象的上次访问时间和访问次数。\nrefcount：存储当前对象的引用次数，用于内存回收；\nptr：指向实际存储的某一种数据结构。然而，当 robj 存储的数据类型可以用 long 类型表示，数据会直接存储在 ptr 中。\n字符串 简单动态字符串（sds）是 Redis 的基本数据结构，用于存储字符串和整型数据。\n首先是 sds 的一个简单设计：\n1 2 3 4 5 struct sds { int len; int free; char buf[]; } 在 Redis 3.2 之前，sds 就是这样设计的：\n内容存储在柔性数组 buf 中，因为柔性数组的地址和结构体是连续的，所以一是可以满足随机存取的要求，二是可以直接通过首地址偏移得到结构体的首地址，进而获取其他变量； 由于有 len ，在读写字符串时不依赖“\\0”终止符，保证了二进制安全。 但是这种存储方式内存利用率不高，所以 Redis 按照长度把字符串分为 5 种类型：sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64 ，会用 1 个字节的低 3 位标识字符串类型，高 5 位用于存储字符串长度。以 sdshdr5 为例：\n结构体：\n1 2 3 4 struct __attribute__ ((__packed__))sdshdr5 { unsigned char flags; // 低 3 位标识字符串类型，高 5 位用于存储字符串长度 char buf[]; // 柔性数组，存放实际内容 } 对于长度大于 31B 的字符串，Redis 会把 len 和 free 单独存放，所以除了 sdshdr5 之外的字符串类型结构相同。以 sdshdr16 为例：\n1 2 3 4 5 6 struct __attribute__ ((__packed__))sdshdr16 { uint16_t len; // 2B 存储 buf 中已占用字节数 uint16_t alloc; // 2B 存储 buf 已分配字节数 unsigned char flags; char buf[]; } 列表 Redis 列表对象的底层数据结构是 quicklist。在 Redis 3.2 之前 Redis 用 ziplist（压缩链表） 及 adlist（双向链表） 作为 list 的底层实现。当元素较少且元素长度较小时，Redis 会用 ziplist ，其他条件会用 adlist。而 quicklist 由 list 和 ziplist 结合而成。\nlist：Redis 用的双向非循环链表，3.2 之后加入了表头。\nziplist：ziplist 是一个字节数组，是为了节约内存而设计的数据结构。它的基本结构：zlbytes、zltail、zllen、entry1…、zlend。\nzlbytes：列表字节长度，4B； zltail：表尾元素相对于起始地址的偏移量，4B； zlen：元素数目，2B； entry：元素，可以是字节数组或整数； zlend：结尾，1B。 entry 的编码结构：previous_entry_length、encoding、content：\nprevious_entry_length：表示前一个元素的长度。元素长度小于 254B 时占 1B ，否则占 5B； encoding：当前元素的编码类型，是可变的； content：内容。 ziplist 在两个元素之间插入新元素时会有连锁更新现象，效率很低。\nquicklist：是一个由 ziplist 作为节点的双向链表。\n结构体定义：\n1 2 3 4 5 6 7 8 9 typedef struct quicklist { quicklistNode *head; quicklistnode *tail; unsigned long count; unsigned long len; int fill:16; // 指明每个节点的 ziplist 长度 unsigned int compress:16; // 节点压缩深度 // ... } quicklist; 节点结构体定义：\n1 2 3 4 5 6 7 8 9 10 typedef struct quicklistNode { struct quicklistNode *prev; struct quicklistNode *next; unsigned char *zl; // 该节点对应的 ziplist unsigned int sz; // 整个 ziplist 的大小 unsigned int count:16; unsigned int encoding:2; // 表示是否采用 LZF 压缩算法 unsigned int container:2; // 为 quicklistNode 节点 zl 指向的容器类型：1为 none，2为使用 ziplist unsigned int recompress:1; // 用于表示该节点之前是否被压缩过 } quicklistNode; 当使用 LZF 算法压缩时，quicklistNode 节点指向的结构是 quciklistLZF：\n1 2 3 4 typedef struct quicklistLZF { unsigned int sz; // 被 LZF 算法压缩后的 ziplist 大小 char compressed[]; // 保存压缩后的数组 } quicklistLZF; 关于 LZF 算法内容，略。\n字典 Redis 的字典是通过 Hash 来实现的。\n结构体定义：\n1 2 3 4 5 6 typedef struct dictht { dictEntry **table; // 指针数组，存储键值对 unsigned long size; // table 数组的大小 unsigned long sizemask; // 恒定值，掩码 = size - 1 unsigned long used; // 已存储的元素个数 } sizemask 属性用来计算 key 的索引值，值恒为 size - 1。\nHash 元素结构体定义：\n1 2 3 4 5 6 7 8 9 10 typedef struct dictEntry { void *key; union { void *val; // db.dict 中的 val uint64_t u64; int64_t s64; // db.expires 中存储了过期时间 double d; } v; struct dictEntry *next; // Hash 冲突时指向冲突的元素 } dictEntry; dict 结构体定义：\n1 2 3 4 5 6 7 typedef struct dict { dictType *type; // 该字典对应的特定操作函数 void *privdata; // 该字典所依赖的数据 dictht ht[2]; // Hash 表 long rehasidx; // rehash 标志，默认值为 -1，表示不进行rehash操作 int16_t pauserehash; // 当前运行的安全迭代器数 } 关于字典的扩容：\n申请一块新内存，初次申请默认大小为4个 dictEntry，非首次申请的大小则为当前 Hash 表容量的 1 倍； 把新申请的内存地址赋值给 ht[1] ，并把字典的 rehashidx 标志位改为 0，表示之后需要进行 rehash 操作。 集合 Redis 的集合底层基于 dict 和 intset 实现，当集合类型的元素都处于 64 位有符号整数范围之内时用 intset 存储，其他情况用 dict 存储。\nintset 是一个有序的、存储整型数据的结构，结构体定义如下：\n1 2 3 4 5 typedef struct intset { uint32_t encoding; // 编码类型，决定每个元素占用几个字节 uint32_t length; // 元素个数 int8_t contents[]; // 柔性数组 } intset; intset 会根据待插入的值决定是否需要进行扩容，扩容会修改 encoding 属性的值，进而需要扩展 contents 中原来的元素。可以得到集合的一个简单结论，只要引起了扩容，这个待插入值一定是最值。\n有序集合 Redis 的有序集合没有使用平衡树或红黑树实现，而是跳跃表。跳跃表的效率与红黑树相似，但实现要简单很多。\n跳跃表是一种有序链表的升级版，通过额外的“跳跃层”提高查找效率，接近于二分查找的性能。它的基本结构是：\n跳跃表由多层链表组成，底层是一个普通的有序链表（包含所有数据）。 上层链表是底层链表的“索引”，每一层跳跃表包含一部分关键节点，链接在更高层级。 每层的节点数量逐级减少，形成一种“金字塔”结构，层数越高一般节点越少。 关于层数的生成，每个节点通过随机算法决定是否出现在上一层。这个随机性使跳跃表的性能接近二分查找。\n跳跃表从顶层开始向右查找，直到超过目标值（或者到达链表尾部）。如果当前层找不到，就下移一层继续，直到到底层链表。\n查找、插入、删除的平均时间复杂度是 $O(log⁡n)$ 。\n它具有以下的优势：\n动态性好：插入和删除时只需局部调整，不像平衡二叉树需要全局旋转或调整。\n实现简单：不需要复杂的树平衡操作，代码更易维护。\n空间效率高：相比平衡树，跳跃表额外的索引层占用较小空间。\n跳跃表的结构体定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 typedef struct zskiplistNode { sds ele; // 存储字符串类型数据 double score; // 存储用于排序的分值 struct zskiplistNode *backward; // 回溯指针，指向当前节点最底层的前一个节点。从后向前遍历时使用 struct zskiplistLevel { struct zskiplistNode *forward; // 指向本层下一个节点 unsigned int span; // forward 指针指向的节点与本节点之间的元素个数，值越大，跳过的节点个数越多 } level[]; // level 数组，柔性数组 } zskiplistNode; // 表头 typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length; // 跳跃表长度 int level; // 跳跃表的层高 } zskiplist 的 header 指针指向跳跃表的 head 节点。head 节点的 level 数组元素个数为 32，head 节点不存储任何 member、score值，ele 值为 NULL，score 值为 0 ，也不计入总长度的计算。\nstream 简介 Redis 的 Stream 是一种高效的、功能强大的数据结构，适用于消息队列、日志管理和实时数据处理等场景。它在 Redis 5.0 中引入，提供了一种基于时间序列的数据模型，类似于 Kafka 等消息队列系统，但具有 Redis 的高性能和易用性。\nstream 的基本特性：\n日志结构：\nStream 是按时间排序的日志记录，每条记录包含一个唯一的 ID 和对应的数据。\nID 通常是自动生成的时间戳（形如 1669872150488-0），包含毫秒时间戳和序号。\n消费者组：\n支持消费者组 (Consumer Groups)，允许多个消费者分摊处理消息，提高并行处理能力。 消息在消费者组中只会被一个消费者消费，避免重复处理。 轻量级：\nStream 是内置的数据类型，无需额外配置，易于上手。 Redis 的消息队列功能在一些场景中被广泛使用，特别是在轻量级、低延迟的实时消息处理场景中。相比专业的消息队列中间件（如 RabbitMQ），Redis 的消息队列有其独特的优势和局限性。\nstream 的优势\n高性能、低延迟： Redis 是内存数据库，消息的发布和消费速度非常快，特别适合对延迟敏感的场景。 简化架构： Redis 集成了多种功能（如缓存、存储、队列等），不需要引入额外的消息队列中间件，降低了运维和管理成本。 简单易用： 通过 PUBLISH/SUBSCRIBE 或 Stream 数据结构即可实现消息队列功能，开发和配置简单。 轻量级任务队列： 对于简单任务分发或轻量级的数据流处理，Redis 是一个理想的选择。 Redis 启动流程与事件驱动模型 server 启动过程 初始化配置，包含用户可配置的参数以及命令表的初始化，入口函数为 initServerConfig； 加载并解析配置文件，入口函数为 loadServerConfig； 初始化服务端内部变量，入口函数 initServer； 创建事件循环 eventLoop，入口为 aeEventLoop； 创建 socket 并启动监听，入口为 listenToPort； 创建文件事件与时间事件； 开启事件循环。 事件处理 事件都封装在 aeEventLoop 中，它的定义如下：\n1 2 3 4 5 6 7 8 9 typedef struct aeEventLoop { int stop; // 标志事件结束 aeFileEvent *events; // 文件事件数组 aeFiredEvent *fired; // 已触发事件数组 aeTimeEvent *timeEventHead; // 时间事件链表头节点 void *apidata; // 多路复用的底层实现相关数据 aeBeforeSleepProc *beforesleep; // 事件循环前执行的钩子函数 aeBeforeSleepProc *aftersleep; // 事件循环后执行的钩子函数 } aeEventLoop; Redis 的事件驱动模型是基于事件循环的，它将所有任务分为两类：文件事件（File Event）和时间事件（Time Event），并通过事件循环依次处理这些事件。\nRedis 的事件循环通过函数 aeMain 实现，大致流程如下：\n检查是否需要退出：通过 stop 标志判断是否需要退出事件循环； 处理已触发的文件事件： 调用多路复用器（如 epoll_wait）等待文件事件触发； 收集触发的事件，执行相应的回调函数。 处理到期的时间事件： 遍历时间事件链表，检查当前时间是否已达到某个事件的触发时间； 如果是，则执行该时间事件的回调函数。 执行钩子函数： 在进入或退出休眠状态时，执行 beforesleep 和 aftersleep 钩子函数，完成一些特定的任务（如清理数据或更新状态）。 重复上述步骤，直到事件循环终止。 I/O 多路复用机制 Redis 支持以下几种 I/O 多路复用技术：\nepoll（linux）：\n性能最优，适合大规模并发连接。\n采用事件通知方式，避免了 select 的轮询开销。\nkqueue（macOS）：\n类似于 epoll，性能优越。 select（跨平台）：\n简单但性能差，适合小规模连接。 poll（linux、unix）：\n比 select 稍好，但性能较差。 Redis 使用抽象层封装了多路复用的具体实现，核心接口包括：\naeApiCreate：创建多路复用上下文。 aeApiAddEvent：注册文件描述符及其感兴趣的事件类型（读/写）。 aeApiPoll：阻塞等待事件触发，并将触发的事件写入 fired 数组。 aeApiDelEvent：注销文件描述符上的某个事件类型。 aeApiFree：释放多路复用器资源。 文件事件 在 Redis 的事件循环机制中，“文件事件（File Event）” 是对可读写的文件描述符（File Descriptor, FD）进行异步处理的核心手段。虽然名为“文件事件”，但实际应用中，它更多用于处理网络套接字（如客户端连接的 TCP Socket）的读写，这与传统的 UNIX 网络编程中“文件描述符既可代表文件又可代表套接字”的概念相呼应。Redis 基本上是通过文件事件来实现非阻塞、单线程的网络 I/O 处理，从而在不依赖多线程的情况下实现高吞吐和低延迟。\nRedis 单线程运行中，为了同时处理众多客户端请求，需要在不阻塞主线程的前提下对 I/O 操作（如读写套接字）进行管理。文件事件模型就是为了解决这个问题而设计的。通过将每一个套接字（客户端连接）注册到事件循环中，当该套接字可读或可写时，事件循环会获悉并调用相应的回调函数进行处理。文件事件基于操作系统的多路复用机制（select、epoll、kqueue），以非阻塞方式高效地管理多个 I/O 通道。\naeFileEvent 是文件事件的核心结构，它的结构体定义：\n1 2 3 4 5 6 typedef struct aeFileEvent { int mask; // 事件类型掩码，可以是 AE_READABLE 或 AE_WRITABLE 或两者的组合 aeFileProc *rfileProc; // 可读事件的回调函数 aeFileProc *wfileProc; // 可写事件的回调函数 void *clientData; // 用户数据，可以传递给回调函数 } aeFileEvent; 文件事件有几个实现的关键点：\n事件注册与管理： aeEventLoop 的 events 属性中，每个 FD 对应一个 aeFileEvent ； 注册文件事件时，调用 aeCreateFileEvent 将 FD 与事件类型绑定，同时更新底层多路复用器的监听列表。 事件监听与触发： Redis 使用多路复用器监听所有注册的 FD 的状态变化，多路复用器由 aeApiPoll 实现； 多路复用器会在事件发生时返回触发的 FD 和事件类型。 事件分发与处理： Redis 将触发的文件事件存入 aeEventLoop 的 fired 数组； 遍历 fired 数组，根据 FD 查找对应的 aeFileEvent 并执行绑定的回调函数。 一个较完整的文件事件的流程：\n初始化事件循环 aeEventLoop ； 用 aeCreateFileEvent 注册文件事件； 事件循环： Redis 使用 aeProcessEvents 处理事件： 等待事件发生：调用 aeApiPoll 阻塞等待 FD 的状态变化； 收集触发事件：将触发的事件放入 fired 数组； 执行回调函数：遍历 fired 数组，调用回调函数。 注销文件事件：当 FD 不再需要被监听了，调用aeDeleteFileEvent 注销事件并更新多路复用器。 时间事件 时间事件是基于定时触发的回调机制，用于在特定时间点或周期性地执行特定任务。例如，Redis 中的一些周期性操作（如服务器内部维护、过期键清理、统计信息更新）都是通过时间事件来实现的。\nRedis 使用一个单向链表管理所有注册的时间事件，头指针就是 aeEventLoop 中的 timeEventHead 属性。时间事件的核心结构是 aeTimeEvent：\n1 2 3 4 5 6 7 8 typedef struct aeTimeEvent { long long id; // 时间事件的唯一标识符 long whenSec; // 事件触发的时间（秒级） long whenMs; // 事件触发的时间（毫秒级，与 whenSec 合用可表示一个精确时间点） aeTimeProc *timeProc; // 时间事件的回调函数 aeEventFinalizerProc *finalizerProc; // 可选的清理回调函数，当时间事件删除时调用 struct aeTimeEvent *next; // 下一个时间事件的指针 } aeTimeEvent; 时间事件的触发与处理流程：\n事件检查与触发时机：\n时间事件并非由操作系统机制直接触发，而是由 Redis 在事件循环每一轮迭代（aeProcessEvents 调用）中自行检查当前时间与事件的触发时间是否匹配：\nRedis 在执行 aeProcessEvents 时，先处理文件事件，然后调用 aeProcessTimeEvents 遍历 timeEventHead 链表； 对于每个时间事件，Redis 获取当前系统时间并与 whenSec、whenMs 对比。如果当前时间已达或超过事件设定的触发时间，则执行 timeProc 回调函数。 执行回调函数与事件重设：\n当执行 timeProc 时：\n若返回 -1，该时间事件时一次性执行，执行结束后立即删除该事件； 若返回整数（毫秒数），则 Redis 会在当前执行时间基础上增加该毫秒作为下次触发时间，这样就实现了周期性执行的逻辑。 事件清理：如果事件执行结束或调用 aeDeleteTimeEvent 删除，Redis 会调用 finalizerProc 进行清理。\nRedis 多线程模型 I/O 多线程 在 Redis 6.0 之前，读取客户端命令、执行命令以及向客户端返回结果都是在主线程完成的。Redis 执行命令速度非常快，但是另外两个操作，也就是网络 I/O 就成了性能瓶颈。所以 6.0 之后，Redis 加入了多线程 I/O 。\nRedis 的 I/O 多线程并不是让整个 Redis 服务都运行在多线程模式下，而是专注于网络 I/O（例如读取客户端请求和发送响应）。其他任务（如命令执行、键空间操作等）仍然由主线程完成。\n具体过程：\n主线程监听网络事件： 主线程接收客户端连接和网络事件，分配这些事件给线程池中的 I/O 线程。 I/O 线程并行处理网络数据： 每个线程处理一组客户端连接，负责从 socket 中读取数据或将数据写回 socket。 主线程处理命令逻辑： 当 I/O 线程完成数据的读取后，主线程解析命令并执行。 结果由主线程统一交给 I/O 线程写回客户端。 I/O 线程管理 Redis 通过配置文件和启动参数管理 I/O 线程。默认情况下，Redis 的多线程支持是关闭的，且线程数量设置为 1（即单线程模式）。\n配置参数：\nio-threads：\n用于设置 Redis 的 I/O 线程数量。 值必须大于等于 1（默认值为 1 表示单线程）。 示例：\n1 io-threads 4 io-threads-do-reads：\n控制是否使用多线程处理读取操作。 值为 yes 时，启用多线程读取；no 时，读取操作仍由主线程完成（默认值为 no）。 示例：\n1 io-threads-do-reads yes 线程池管理：\nRedis 的线程池在启动时创建，线程数量固定。 Redis 不会动态调整线程池的大小，因此需要根据工作负载合理配置线程数量。 I/O 线程同步 Redis 的 I/O 线程同步主要体现在两个阶段：\nI/O 线程之间的同步（多线程并行读取/写入时的安全）。 I/O 线程和主线程的同步（确保主线程正确处理数据）。 关于 I/O 线程之间的同步，Redis 采用任务分片和线程本地数据隔离的方式：\n任务分片：每个 I/O 线程负责一组客户端连接，客户端连接的分配由主线程完成，各线程的任务互不重叠。 线程本地缓冲区：Redis 为每个 I/O 线程分配自己的输入/输出缓冲区，线程在处理网络 I/O 时，只会操作属于自己的缓冲区，不会访问其他线程的数据。 分阶段处理：所有线程在同一个阶段完成任务，等到所有线程完成后，才进入下一阶段（如命令解析）。 而 I/O 线程与主线程之间的同步是在两个节点上进行的：\nI/O 线程完成数据读取后，通知主线程解析和执行命令。 主线程执行完命令后，通知 I/O 线程将结果写回客户端。 为此，Redis 使用了以下机制：\n主线程全局控制权：主线程是唯一负责命令解析和执行的线程。 分阶段锁：主线程会等待所有 I/O 线程完成当前阶段的任务（如读取或写入）后，才进入下一阶段。阶段结束的标志由主线程统一检查。 轻量级同步标志：Redis 使用轻量级的同步机制（如原子操作和状态标志）协调主线程和 I/O 线程的状态，而不是引入复杂的锁机制。 Redis 在线程同步中会使用以下几种锁机制：\n互斥锁（Mutex） ​\tRedis 使用操作系统提供的互斥锁（pthread_mutex）来保护关键资源。这种锁是重量级锁，只有在不可避免的情况下才会使用。\n使用场景： 保护客户端连接列表的修改。 保护任务队列的操作。 确保线程安全的统计信息更新。 优缺点： 优点：简单可靠，适用于临界区较少的场景。 缺点：加锁和解锁需要上下文切换，可能增加线程之间的等待时间。 自旋锁（Spinlock） ​\tRedis 更倾向于使用自旋锁（pthread_spinlock）来减少线程等待的开销。在自旋锁中，线程不会进入睡眠状态，而是不断轮询锁的状态，直到获取锁为止。\n使用场景： 临界区非常小且操作耗时短的场景，例如更新统计信息或同步标志。 自旋锁适用于高并发、锁持有时间短的情况，可以避免线程切换的开销。 优缺点： 优点：高效，适合临界区操作非常快的场景。 缺点：如果锁被长时间持有，会浪费 CPU 资源。 原子操作（Atomic Operation） ​\tRedis 使用原子操作（例如 __sync_fetch_and_add 或 stdatomic.h 提供的接口）来同步一些简单的共享数据，例如计数器或标志位。\n使用场景： 更新 I/O 线程的完成计数。 统计信息（如处理的命令数量）的更新。 优缺点： 优点：无需显式加锁，性能极高。 缺点：只适用于简单的原子性操作，无法保护复杂的共享资源。 持久化 （这本书中关于持久化的内容全是围绕源码讲的，对于现阶段没有帮助，所以此章内容为参考网络资料整理而来。）\nRDB RDB（Redis Database） 是通过在特定时间间隔或满足特定触发条件时，将内存中的数据集状态“快照”（Snapshot）地保存到磁盘文件（一般为 dump.rdb）中。该文件使用二进制格式，包含 Redis 数据库在某个时间点上的所有数据状态。\nRedis 的 RDB 持久化通常通过两种方式触发：\n后台定时保存（自动快照）：在 redis.conf 中，通过配置 save 命令设置保存条件。例如：\n1 2 3 save 900 1 # 900秒（15分钟）内如果至少有1个key被修改就触发一次RDB保存 save 300 10 # 300秒（5分钟）内如果至少有10个key被修改就触发一次RDB保存 save 60 10000 # 60秒（1分钟）内如果至少有10000个key被修改就触发一次RDB保存 当满足任意一个条件时，Redis 会触发一次 RDB 快照。\n手动触发：可以在客户端执行 BGSAVE 命令（推荐）或 SAVE 命令。\nBGSAVE 会在后台子进程中创建一个快照，这个过程中并不会阻塞主线程的命令处理，因此对服务影响较小。 SAVE 则是在当前进程中执行快照生成，在保存期间阻塞所有客户端请求，一般不推荐在线上环境使用。 RDB 持久化的特点\n优点： 文件紧凑：RDB 文件是二进制压缩格式，体积较小，便于传输和备份。 恢复快速：RDB 文件包含某个时刻的全量数据快照，重启时直接加载就能快速恢复到该时刻的状态。 性能影响相对较小：在使用 BGSAVE 时，快照工作由子进程完成，主进程依旧可以响应请求，整体对服务性能影响相对可控。 缺点： 潜在数据丢失：因为 RDB 不是实时保存数据，而是以一定周期或条件触发，那么在上一次 RDB 之后的修改操作若 Redis 意外崩溃，这些修改将丢失。 高并发下的开销：在进行 RDB 快照时需要 fork 子进程，复制内存页，若数据量很大，可能造成一定的性能抖动。 AOF AOF 模式通过记录 每一次对 Redis 数据进行修改的命令 来实现持久化。它会将 Redis 的写操作（如 SET、HSET、INCR 等）以文本协议的形式追加到 AOF 文件（默认 appendonly.aof）末尾。\nAOF 的写策略可以通过 appendfsync 参数控制：\nappendfsync always：每次有写操作都同步（fsync）到磁盘，安全性最高但性能开销最大。 appendfsync everysec：每秒强制进行一次磁盘同步，是默认策略，也是性能和安全的较好平衡点。在极端崩溃情况下，最多丢失1秒的数据。 appendfsync no：不主动调用 fsync 由操作系统决定磁盘刷新时间，性能最好但可能丢失更多数据。 由于 AOF 通过不断追加命令记录，随着时间推移文件会越来越大。为解决文件过大的问题，Redis 提供 AOF 重写机制。当 AOF 文件达到一定大小门限（可配置），Redis 会自动触发 AOF 重写（BGREWRITEAOF），过程如下：\nRedis fork 出一个子进程。 子进程根据当前内存数据状态生成一份最精简的命令集，将这些命令写入一个新的 AOF 临时文件。 在此过程中，主进程仍在接受新写入操作，这些操作会同时被写入内存缓冲区，并在子进程完成重写后，追加到新的 AOF 文件末尾。 当子进程完成重写后，用新的 AOF 文件替换旧文件，从而实现 AOF 文件的压缩精简。 通过 AOF 重写机制，可以保证 AOF 文件不会无限增长。\nAOF 的特点\n优点： 数据安全性高：AOF 可以在更高频率（如每秒甚至每次写入）下同步数据到磁盘，从而最大限度地减少数据丢失。 文件易读性：AOF 是文本协议格式，打开文件就能看到具体的 Redis 命令，有利于故障排查。 缺点： 文件可能较大：相较于 RDB，AOF 的文件会因为不断记录写操作而变得更大。不过可以通过重写来缓解。 恢复速度稍慢：在恢复数据时，Redis 需要从头按顺序执行 AOF 文件中的所有写操作命令，处理耗时可能比加载 RDB 文件长（不过通过 AOF 重写可有效缩短恢复时间）。 混合持久化 Redis 4.0 及以上版本引入了混合持久化的机制，即在进行 AOF 重写时，可以将当前内存数据的 RDB 格式和后续增量的命令相结合，从而在恢复时既能快速加载 RDB 部分，又能保证数据的完整性。Redis 5.0 开始默认开启混合持久化。\n混合持久化在进行 AOF 重写时，先写入一段 RDB 格式的二进制数据（表示当前快照状态），然后在此之后附加增量的 AOF 命令部分。这样恢复数据时先读 RDB 部分（极快恢复大部分数据），然后再应用后面的 AOF 命令（补齐最新写入的数据），实现恢复性能与数据完整性间的平衡。\n","wordCount":"1410","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-12-05T00:00:00Z","dateModified":"2024-12-05T00:00:00Z","author":{"@type":"Person","name":"Kurong"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/dailydev/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8redis%E8%AE%B0%E5%BD%95/"},"publisher":{"@type":"Organization","name":"KurongBlog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">《高效使用Redis》记录</h1><div class=post-meta><span title='2024-12-05 00:00:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;Kurong&nbsp;|&nbsp;<a href=https://github.com/KurongTohsaka/KurongTohsaka.github.io/content/posts/DailyDev/%e3%80%8a%e9%ab%98%e6%95%88%e4%bd%bf%e7%94%a8Redis%e3%80%8b%e8%ae%b0%e5%bd%95.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#基础数据结构解析>基础数据结构解析</a><ul><li><a href=#对象>对象</a></li><li><a href=#字符串>字符串</a></li><li><a href=#列表>列表</a></li><li><a href=#字典>字典</a></li><li><a href=#集合>集合</a></li><li><a href=#有序集合>有序集合</a></li></ul></li><li><a href=#stream-简介>stream 简介</a></li><li><a href=#redis-启动流程与事件驱动模型>Redis 启动流程与事件驱动模型</a><ul><li><a href=#server-启动过程>server 启动过程</a></li><li><a href=#事件处理>事件处理</a></li><li><a href=#io-多路复用机制>I/O 多路复用机制</a></li><li><a href=#文件事件>文件事件</a></li><li><a href=#时间事件>时间事件</a></li></ul></li><li><a href=#redis-多线程模型>Redis 多线程模型</a><ul><li><a href=#io-多线程>I/O 多线程</a></li><li><a href=#io-线程管理>I/O 线程管理</a></li><li><a href=#io-线程同步>I/O 线程同步</a></li></ul></li><li><a href=#持久化>持久化</a><ul><li><a href=#rdb>RDB</a></li><li><a href=#aof>AOF</a></li><li><a href=#混合持久化>混合持久化</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=高效使用redis记录>《高效使用Redis》记录<a hidden class=anchor aria-hidden=true href=#高效使用redis记录>#</a></h1><h2 id=基础数据结构解析>基础数据结构解析<a hidden class=anchor aria-hidden=true href=#基础数据结构解析>#</a></h2><h3 id=对象>对象<a hidden class=anchor aria-hidden=true href=#对象>#</a></h3><p>Redis中的 RedisObject 的 c 定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define LRU_BITS 24
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>redisObject</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=nl>type</span><span class=p>:</span><span class=mi>4</span><span class=p>;</span>  <span class=c1>// 数据类型
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=nl>encoding</span><span class=p>:</span><span class=mi>4</span><span class=p>;</span>  <span class=c1>// 底层数据结构
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=nl>lru</span><span class=p>:</span><span class=n>LRU_BITS</span><span class=p>;</span>  <span class=c1>// 缓存淘汰时使用
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>refcount</span><span class=p>;</span>  <span class=c1>// 引用计数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>  <span class=c1>// 指向实际存储位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>robj</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>RedisObject 是 Redis 中数据结构的一个抽象，用它来存储所有的 key-value 数据。</p><p>下面是结构体中各个属性的。说明：</p><ul><li><p>type：用来表示对象类型；</p></li><li><p>encoding：表示当前对象底层存储所采用的数据结构，如int、字典、压缩列表、跳跃表等等；</p></li><li><p>lru：用于在配置文件中通过 maxmemory-policy 配置已用内存到最大内存限制时的缓存淘汰策略。</p><ul><li><p>以 GET 命令为例，简单看看 Redis 中的 LRU 实现。使用 GET 后，会执行这段代码更新对象的 lru 属性：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>server</span><span class=p>.</span><span class=n>maxmemory_policy</span> <span class=o>&amp;</span> <span class=n>MAXMEMORY_FLAG_LRU</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>uodateLFU</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>val</span><span class=o>-&gt;</span><span class=n>lru</span> <span class=o>=</span> <span class=nf>LRU_CLOCK</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>LRU_CLOCK 用于获取当前时间，但并不是实时获取。Redis 每 1s 执行系统调用来获取精确时间，然后存储在全局变量 server.lruclock 中，LRU_CLOCK 只是获取该缓存时间。updateLFU 用于更新对象的上次访问时间和访问次数。</p></li></ul></li><li><p>refcount：存储当前对象的引用次数，用于内存回收；</p></li><li><p>ptr：指向实际存储的某一种数据结构。然而，当 robj 存储的数据类型可以用 long 类型表示，数据会直接存储在 ptr 中。</p></li></ul><h3 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h3><p>简单动态字符串（sds）是 Redis 的基本数据结构，用于存储字符串和整型数据。</p><p>首先是 sds 的一个简单设计：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sds</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在 Redis 3.2 之前，sds 就是这样设计的：</p><ul><li>内容存储在柔性数组 buf 中，因为柔性数组的地址和结构体是连续的，所以一是可以满足随机存取的要求，二是可以直接通过首地址偏移得到结构体的首地址，进而获取其他变量；</li><li>由于有 len ，在读写字符串时不依赖“\0”终止符，保证了二进制安全。</li></ul><p>但是这种存储方式内存利用率不高，所以 Redis 按照长度把字符串分为 5 种类型：sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64 ，会用 1 个字节的低 3 位标识字符串类型，高 5 位用于存储字符串长度。以 sdshdr5 为例：</p><ul><li><p>结构体：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>__packed__</span><span class=p>))</span><span class=n>sdshdr5</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>flags</span><span class=p>;</span>  <span class=c1>// 低 3 位标识字符串类型，高 5 位用于存储字符串长度
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[];</span>  <span class=c1>// 柔性数组，存放实际内容 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>对于长度大于 31B 的字符串，Redis 会把 len 和 free 单独存放，所以除了 sdshdr5 之外的字符串类型结构相同。以 sdshdr16 为例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>__packed__</span><span class=p>))</span><span class=n>sdshdr16</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint16_t</span> <span class=n>len</span><span class=p>;</span>  <span class=c1>// 2B 存储 buf 中已占用字节数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint16_t</span> <span class=n>alloc</span><span class=p>;</span>  <span class=c1>// 2B 存储 buf 已分配字节数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=列表>列表<a hidden class=anchor aria-hidden=true href=#列表>#</a></h3><p>Redis 列表对象的底层数据结构是 quicklist。在 Redis 3.2 之前 Redis 用 ziplist（压缩链表） 及 adlist（双向链表） 作为 list 的底层实现。当元素较少且元素长度较小时，Redis 会用 ziplist ，其他条件会用 adlist。而 quicklist 由 list 和 ziplist 结合而成。</p><ul><li><p>list：Redis 用的双向非循环链表，3.2 之后加入了表头。</p></li><li><p>ziplist：ziplist 是一个字节数组，是为了节约内存而设计的数据结构。它的基本结构：zlbytes、zltail、zllen、entry1…、zlend。</p><ul><li>zlbytes：列表字节长度，4B；</li><li>zltail：表尾元素相对于起始地址的偏移量，4B；</li><li>zlen：元素数目，2B；</li><li>entry：元素，可以是字节数组或整数；</li><li>zlend：结尾，1B。</li></ul><p>entry 的编码结构：previous_entry_length、encoding、content：</p><ul><li>previous_entry_length：表示前一个元素的长度。元素长度小于 254B 时占 1B ，否则占 5B；</li><li>encoding：当前元素的编码类型，是可变的；</li><li>content：内容。</li></ul><p>ziplist 在两个元素之间插入新元素时会有连锁更新现象，效率很低。</p></li><li><p>quicklist：是一个由 ziplist 作为节点的双向链表。</p><p>结构体定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8>8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklist</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>quicklistnode</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nl>fill</span><span class=p>:</span><span class=mi>16</span><span class=p>;</span>  <span class=c1>// 指明每个节点的 ziplist 长度
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>compress</span><span class=p>:</span><span class=mi>16</span><span class=p>;</span>  <span class=c1>// 节点压缩深度
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>quicklist</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>节点结构体定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>zl</span><span class=p>;</span>  <span class=c1>// 该节点对应的 ziplist
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span>  <span class=c1>// 整个 ziplist 的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>count</span><span class=p>:</span><span class=mi>16</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>encoding</span><span class=p>:</span><span class=mi>2</span><span class=p>;</span>  <span class=c1>// 表示是否采用 LZF 压缩算法
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>container</span><span class=p>:</span><span class=mi>2</span><span class=p>;</span>  <span class=c1>// 为 quicklistNode 节点 zl 指向的容器类型：1为 none，2为使用 ziplist
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>recompress</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>  <span class=c1>// 用于表示该节点之前是否被压缩过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>quicklistNode</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>当使用 LZF 算法压缩时，quicklistNode 节点指向的结构是 quciklistLZF：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistLZF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span>  <span class=c1>// 被 LZF 算法压缩后的 ziplist 大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>compressed</span><span class=p>[];</span>  <span class=c1>// 保存压缩后的数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>quicklistLZF</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>关于 LZF 算法内容，略。</p></li></ul><h3 id=字典>字典<a hidden class=anchor aria-hidden=true href=#字典>#</a></h3><p>Redis 的字典是通过 Hash 来实现的。</p><p>结构体定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>dictht</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>dictEntry</span> <span class=o>**</span><span class=n>table</span><span class=p>;</span>  <span class=c1>// 指针数组，存储键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>size</span><span class=p>;</span>  <span class=c1>// table 数组的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>sizemask</span><span class=p>;</span>  <span class=c1>// 恒定值，掩码 = size - 1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>used</span><span class=p>;</span>  <span class=c1>// 已存储的元素个数 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>sizemask 属性用来计算 key 的索引值，值恒为 size - 1。</p><p>Hash 元素结构体定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>dictEntry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>val</span><span class=p>;</span>  <span class=c1>// db.dict 中的 val
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>u64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int64_t</span> <span class=n>s64</span><span class=p>;</span>  <span class=c1>// db.expires 中存储了过期时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>dictEntry</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>  <span class=c1>// Hash 冲突时指向冲突的元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>dictEntry</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>dict 结构体定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>dict</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>dictType</span> <span class=o>*</span><span class=n>type</span><span class=p>;</span>  <span class=c1>// 该字典对应的特定操作函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>privdata</span><span class=p>;</span>  <span class=c1>// 该字典所依赖的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>dictht</span> <span class=n>ht</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>  <span class=c1>// Hash 表
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>long</span> <span class=n>rehasidx</span><span class=p>;</span>  <span class=c1>// rehash 标志，默认值为 -1，表示不进行rehash操作
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int16_t</span> <span class=n>pauserehash</span><span class=p>;</span>  <span class=c1>// 当前运行的安全迭代器数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>关于字典的扩容：</p><ol><li>申请一块新内存，初次申请默认大小为4个 dictEntry，非首次申请的大小则为当前 Hash 表容量的 1 倍；</li><li>把新申请的内存地址赋值给 ht[1] ，并把字典的 rehashidx 标志位改为 0，表示之后需要进行 rehash 操作。</li></ol><h3 id=集合>集合<a hidden class=anchor aria-hidden=true href=#集合>#</a></h3><p>Redis 的集合底层基于 dict 和 intset 实现，当集合类型的元素都处于 64 位有符号整数范围之内时用 intset 存储，其他情况用 dict 存储。</p><p>intset 是一个有序的、存储整型数据的结构，结构体定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>intset</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>encoding</span><span class=p>;</span>  <span class=c1>// 编码类型，决定每个元素占用几个字节
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint32_t</span> <span class=n>length</span><span class=p>;</span>  <span class=c1>// 元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int8_t</span> <span class=n>contents</span><span class=p>[];</span>  <span class=c1>// 柔性数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>intset</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>intset 会根据待插入的值决定是否需要进行扩容，扩容会修改 encoding 属性的值，进而需要扩展 contents 中原来的元素。可以得到集合的一个简单结论，只要引起了扩容，这个待插入值一定是最值。</p><h3 id=有序集合>有序集合<a hidden class=anchor aria-hidden=true href=#有序集合>#</a></h3><p>Redis 的有序集合没有使用平衡树或红黑树实现，而是跳跃表。跳跃表的效率与红黑树相似，但实现要简单很多。</p><p>跳跃表是一种有序链表的升级版，通过额外的“跳跃层”提高查找效率，接近于二分查找的性能。它的基本结构是：</p><ul><li>跳跃表由多层链表组成，底层是一个普通的有序链表（包含所有数据）。</li><li>上层链表是底层链表的“索引”，每一层跳跃表包含一部分关键节点，链接在更高层级。</li><li>每层的节点数量逐级减少，形成一种“金字塔”结构，层数越高一般节点越少。</li></ul><p>关于层数的生成，每个节点通过随机算法决定是否出现在上一层。这个随机性使跳跃表的性能接近二分查找。</p><p>跳跃表从顶层开始向右查找，直到超过目标值（或者到达链表尾部）。如果当前层找不到，就下移一层继续，直到到底层链表。</p><p>查找、插入、删除的平均时间复杂度是 $O(log⁡n)$ 。</p><p>它具有以下的优势：</p><ul><li><p>动态性好：插入和删除时只需局部调整，不像平衡二叉树需要全局旋转或调整。</p></li><li><p>实现简单：不需要复杂的树平衡操作，代码更易维护。</p></li><li><p>空间效率高：相比平衡树，跳跃表额外的索引层占用较小空间。</p></li></ul><p>跳跃表的结构体定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>sds</span> <span class=n>ele</span><span class=p>;</span>  <span class=c1>// 存储字符串类型数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>double</span> <span class=n>score</span><span class=p>;</span>  <span class=c1>// 存储用于排序的分值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>backward</span><span class=p>;</span>  <span class=c1>// 回溯指针，指向当前节点最底层的前一个节点。从后向前遍历时使用
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>zskiplistLevel</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>forward</span><span class=p>;</span>  <span class=c1>// 指向本层下一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>span</span><span class=p>;</span>  <span class=c1>// forward 指针指向的节点与本节点之间的元素个数，值越大，跳过的节点个数越多
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=n>level</span><span class=p>[];</span>  <span class=c1>// level 数组，柔性数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>zskiplistNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 表头
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>zskiplist</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>header</span><span class=p>,</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>length</span><span class=p>;</span>  <span class=c1>// 跳跃表长度
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>level</span><span class=p>;</span>  <span class=c1>// 跳跃表的层高
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>zskiplist 的 header 指针指向跳跃表的 head 节点。head 节点的 level 数组元素个数为 32，head 节点不存储任何 member、score值，ele 值为 NULL，score 值为 0 ，也不计入总长度的计算。</p><h2 id=stream-简介>stream 简介<a hidden class=anchor aria-hidden=true href=#stream-简介>#</a></h2><p>Redis 的 Stream 是一种高效的、功能强大的数据结构，适用于消息队列、日志管理和实时数据处理等场景。它在 Redis 5.0 中引入，提供了一种基于时间序列的数据模型，类似于 Kafka 等消息队列系统，但具有 Redis 的高性能和易用性。</p><p>stream 的基本特性：</p><ul><li><p>日志结构：</p><ul><li><p>Stream 是按时间排序的日志记录，每条记录包含一个唯一的 ID 和对应的数据。</p></li><li><p>ID 通常是自动生成的时间戳（形如 <code>1669872150488-0</code>），包含毫秒时间戳和序号。</p></li></ul></li><li><p>消费者组：</p><ul><li>支持消费者组 (Consumer Groups)，允许多个消费者分摊处理消息，提高并行处理能力。</li><li>消息在消费者组中只会被一个消费者消费，避免重复处理。</li></ul></li><li><p>轻量级：</p><ul><li>Stream 是内置的数据类型，无需额外配置，易于上手。</li></ul></li></ul><p>Redis 的消息队列功能在一些场景中被广泛使用，特别是在轻量级、低延迟的实时消息处理场景中。相比专业的消息队列中间件（如 RabbitMQ），Redis 的消息队列有其独特的优势和局限性。</p><p>stream 的优势</p><ol><li>高性能、低延迟：<ul><li>Redis 是内存数据库，消息的发布和消费速度非常快，特别适合对延迟敏感的场景。</li></ul></li><li>简化架构：<ul><li>Redis 集成了多种功能（如缓存、存储、队列等），不需要引入额外的消息队列中间件，降低了运维和管理成本。</li></ul></li><li>简单易用：<ul><li>通过 PUBLISH/SUBSCRIBE 或 Stream 数据结构即可实现消息队列功能，开发和配置简单。</li></ul></li><li>轻量级任务队列：<ul><li>对于简单任务分发或轻量级的数据流处理，Redis 是一个理想的选择。</li></ul></li></ol><h2 id=redis-启动流程与事件驱动模型>Redis 启动流程与事件驱动模型<a hidden class=anchor aria-hidden=true href=#redis-启动流程与事件驱动模型>#</a></h2><h3 id=server-启动过程>server 启动过程<a hidden class=anchor aria-hidden=true href=#server-启动过程>#</a></h3><ol><li>初始化配置，包含用户可配置的参数以及命令表的初始化，入口函数为 initServerConfig；</li><li>加载并解析配置文件，入口函数为 loadServerConfig；</li><li>初始化服务端内部变量，入口函数 initServer；</li><li>创建事件循环 eventLoop，入口为 aeEventLoop；</li><li>创建 socket 并启动监听，入口为 listenToPort；</li><li>创建文件事件与时间事件；</li><li>开启事件循环。</li></ol><h3 id=事件处理>事件处理<a hidden class=anchor aria-hidden=true href=#事件处理>#</a></h3><p>事件都封装在 aeEventLoop 中，它的定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5>5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6>6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7>7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8>8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>aeEventLoop</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>stop</span><span class=p>;</span>  <span class=c1>// 标志事件结束
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>aeFileEvent</span> <span class=o>*</span><span class=n>events</span><span class=p>;</span>  <span class=c1>// 文件事件数组
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>aeFiredEvent</span> <span class=o>*</span><span class=n>fired</span><span class=p>;</span>  <span class=c1>// 已触发事件数组
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>aeTimeEvent</span> <span class=o>*</span><span class=n>timeEventHead</span><span class=p>;</span>  <span class=c1>// 时间事件链表头节点
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>apidata</span><span class=p>;</span>  <span class=c1>// 多路复用的底层实现相关数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>aeBeforeSleepProc</span> <span class=o>*</span><span class=n>beforesleep</span><span class=p>;</span>  <span class=c1>// 事件循环前执行的钩子函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>aeBeforeSleepProc</span> <span class=o>*</span><span class=n>aftersleep</span><span class=p>;</span>  <span class=c1>// 事件循环后执行的钩子函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>aeEventLoop</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>Redis 的事件驱动模型是基于事件循环的，它将所有任务分为两类：文件事件（File Event）和时间事件（Time Event），并通过事件循环依次处理这些事件。</p><p>Redis 的事件循环通过函数 aeMain 实现，大致流程如下：</p><ol><li>检查是否需要退出：通过 stop 标志判断是否需要退出事件循环；</li><li>处理已触发的文件事件：<ul><li>调用多路复用器（如 epoll_wait）等待文件事件触发；</li><li>收集触发的事件，执行相应的回调函数。</li></ul></li><li>处理到期的时间事件：<ul><li>遍历时间事件链表，检查当前时间是否已达到某个事件的触发时间；</li><li>如果是，则执行该时间事件的回调函数。</li></ul></li><li>执行钩子函数：<ul><li>在进入或退出休眠状态时，执行 beforesleep 和 aftersleep 钩子函数，完成一些特定的任务（如清理数据或更新状态）。</li></ul></li><li>重复上述步骤，直到事件循环终止。</li></ol><h3 id=io-多路复用机制>I/O 多路复用机制<a hidden class=anchor aria-hidden=true href=#io-多路复用机制>#</a></h3><p>Redis 支持以下几种 I/O 多路复用技术：</p><ul><li><p>epoll（linux）：</p><ul><li><p>性能最优，适合大规模并发连接。</p></li><li><p>采用事件通知方式，避免了 select 的轮询开销。</p></li></ul></li><li><p>kqueue（macOS）：</p><ul><li>类似于 epoll，性能优越。</li></ul></li><li><p>select（跨平台）：</p><ul><li>简单但性能差，适合小规模连接。</li></ul></li><li><p>poll（linux、unix）：</p><ul><li>比 select 稍好，但性能较差。</li></ul></li></ul><p>Redis 使用抽象层封装了多路复用的具体实现，核心接口包括：</p><ul><li><strong><code>aeApiCreate</code></strong>：创建多路复用上下文。</li><li><strong><code>aeApiAddEvent</code></strong>：注册文件描述符及其感兴趣的事件类型（读/写）。</li><li><strong><code>aeApiPoll</code></strong>：阻塞等待事件触发，并将触发的事件写入 fired 数组。</li><li><strong><code>aeApiDelEvent</code></strong>：注销文件描述符上的某个事件类型。</li><li><strong><code>aeApiFree</code></strong>：释放多路复用器资源。</li></ul><h3 id=文件事件>文件事件<a hidden class=anchor aria-hidden=true href=#文件事件>#</a></h3><p>在 Redis 的事件循环机制中，&ldquo;文件事件（File Event）&rdquo; 是对可读写的文件描述符（File Descriptor, FD）进行异步处理的核心手段。虽然名为“文件事件”，但实际应用中，它更多用于处理网络套接字（如客户端连接的 TCP Socket）的读写，这与传统的 UNIX 网络编程中“文件描述符既可代表文件又可代表套接字”的概念相呼应。Redis 基本上是通过文件事件来实现非阻塞、单线程的网络 I/O 处理，从而在不依赖多线程的情况下实现高吞吐和低延迟。</p><p>Redis 单线程运行中，为了同时处理众多客户端请求，需要在不阻塞主线程的前提下对 I/O 操作（如读写套接字）进行管理。文件事件模型就是为了解决这个问题而设计的。通过将每一个套接字（客户端连接）注册到事件循环中，当该套接字可读或可写时，事件循环会获悉并调用相应的回调函数进行处理。文件事件基于操作系统的多路复用机制（select、epoll、kqueue），以非阻塞方式高效地管理多个 I/O 通道。</p><p>aeFileEvent 是文件事件的核心结构，它的结构体定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5>5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>aeFileEvent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mask</span><span class=p>;</span>                 <span class=c1>// 事件类型掩码，可以是 AE_READABLE 或 AE_WRITABLE 或两者的组合
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>aeFileProc</span> <span class=o>*</span><span class=n>rfileProc</span><span class=p>;</span>    <span class=c1>// 可读事件的回调函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>aeFileProc</span> <span class=o>*</span><span class=n>wfileProc</span><span class=p>;</span>    <span class=c1>// 可写事件的回调函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>clientData</span><span class=p>;</span>         <span class=c1>// 用户数据，可以传递给回调函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>aeFileEvent</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>文件事件有几个实现的关键点：</p><ul><li>事件注册与管理：<ul><li>aeEventLoop 的 events 属性中，每个 FD 对应一个 aeFileEvent ；</li><li>注册文件事件时，调用 aeCreateFileEvent 将 FD 与事件类型绑定，同时更新底层多路复用器的监听列表。</li></ul></li><li>事件监听与触发：<ul><li>Redis 使用多路复用器监听所有注册的 FD 的状态变化，多路复用器由 aeApiPoll 实现；</li><li>多路复用器会在事件发生时返回触发的 FD 和事件类型。</li></ul></li><li>事件分发与处理：<ul><li>Redis 将触发的文件事件存入 aeEventLoop 的 fired 数组；</li><li>遍历 fired 数组，根据 FD 查找对应的 aeFileEvent 并执行绑定的回调函数。</li></ul></li></ul><p>一个较完整的文件事件的流程：</p><ol><li>初始化事件循环 aeEventLoop ；</li><li>用 aeCreateFileEvent 注册文件事件；</li><li>事件循环：<ul><li>Redis 使用 aeProcessEvents 处理事件：<ol><li>等待事件发生：调用 aeApiPoll 阻塞等待 FD 的状态变化；</li><li>收集触发事件：将触发的事件放入 fired 数组；</li><li>执行回调函数：遍历 fired 数组，调用回调函数。</li></ol></li></ul></li><li>注销文件事件：当 FD 不再需要被监听了，调用aeDeleteFileEvent 注销事件并更新多路复用器。</li></ol><h3 id=时间事件>时间事件<a hidden class=anchor aria-hidden=true href=#时间事件>#</a></h3><p>时间事件是基于定时触发的回调机制，用于在特定时间点或周期性地执行特定任务。例如，Redis 中的一些周期性操作（如服务器内部维护、过期键清理、统计信息更新）都是通过时间事件来实现的。</p><p>Redis 使用一个单向链表管理所有注册的时间事件，头指针就是 aeEventLoop 中的 timeEventHead 属性。时间事件的核心结构是 aeTimeEvent：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6>6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7>7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>aeTimeEvent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=kt>long</span> <span class=n>id</span><span class=p>;</span>  <span class=c1>// 时间事件的唯一标识符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=n>whenSec</span><span class=p>;</span>  <span class=c1>// 事件触发的时间（秒级）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=n>whenMs</span><span class=p>;</span>   <span class=c1>// 事件触发的时间（毫秒级，与 whenSec 合用可表示一个精确时间点）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>aeTimeProc</span> <span class=o>*</span><span class=n>timeProc</span><span class=p>;</span>  <span class=c1>// 时间事件的回调函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>aeEventFinalizerProc</span> <span class=o>*</span><span class=n>finalizerProc</span><span class=p>;</span>  <span class=c1>// 可选的清理回调函数，当时间事件删除时调用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>aeTimeEvent</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>  <span class=c1>// 下一个时间事件的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>aeTimeEvent</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>时间事件的触发与处理流程：</p><ol><li><p>事件检查与触发时机：</p><p>时间事件并非由操作系统机制直接触发，而是由 Redis 在事件循环每一轮迭代（aeProcessEvents 调用）中自行检查当前时间与事件的触发时间是否匹配：</p><ul><li>Redis 在执行 aeProcessEvents 时，先处理文件事件，然后调用 aeProcessTimeEvents 遍历 timeEventHead 链表；</li><li>对于每个时间事件，Redis 获取当前系统时间并与 whenSec、whenMs 对比。如果当前时间已达或超过事件设定的触发时间，则执行 timeProc 回调函数。</li></ul></li><li><p>执行回调函数与事件重设：</p><p>当执行 timeProc 时：</p><ul><li>若返回 -1，该时间事件时一次性执行，执行结束后立即删除该事件；</li><li>若返回整数（毫秒数），则 Redis 会在当前执行时间基础上增加该毫秒作为下次触发时间，这样就实现了周期性执行的逻辑。</li></ul></li><li><p>事件清理：如果事件执行结束或调用 aeDeleteTimeEvent 删除，Redis 会调用 finalizerProc 进行清理。</p></li></ol><h2 id=redis-多线程模型>Redis 多线程模型<a hidden class=anchor aria-hidden=true href=#redis-多线程模型>#</a></h2><h3 id=io-多线程>I/O 多线程<a hidden class=anchor aria-hidden=true href=#io-多线程>#</a></h3><p>在 Redis 6.0 之前，读取客户端命令、执行命令以及向客户端返回结果都是在主线程完成的。Redis 执行命令速度非常快，但是另外两个操作，也就是网络 I/O 就成了性能瓶颈。所以 6.0 之后，Redis 加入了多线程 I/O 。</p><p>Redis 的 I/O 多线程并不是让整个 Redis 服务都运行在多线程模式下，而是专注于网络 I/O（例如读取客户端请求和发送响应）。其他任务（如命令执行、键空间操作等）仍然由主线程完成。</p><p>具体过程：</p><ol><li>主线程监听网络事件：<ul><li>主线程接收客户端连接和网络事件，分配这些事件给线程池中的 I/O 线程。</li></ul></li><li>I/O 线程并行处理网络数据：<ul><li>每个线程处理一组客户端连接，负责从 socket 中读取数据或将数据写回 socket。</li></ul></li><li>主线程处理命令逻辑：<ul><li>当 I/O 线程完成数据的读取后，主线程解析命令并执行。</li><li>结果由主线程统一交给 I/O 线程写回客户端。</li></ul></li></ol><h3 id=io-线程管理>I/O 线程管理<a hidden class=anchor aria-hidden=true href=#io-线程管理>#</a></h3><p>Redis 通过配置文件和启动参数管理 I/O 线程。默认情况下，Redis 的多线程支持是关闭的，且线程数量设置为 1（即单线程模式）。</p><p>配置参数：</p><ol><li><p>io-threads：</p><ul><li>用于设置 Redis 的 I/O 线程数量。</li><li>值必须大于等于 1（默认值为 1 表示单线程）。</li></ul><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>io-threads 4
</span></span></code></pre></td></tr></table></div></div></li><li><p>io-threads-do-reads：</p><ul><li>控制是否使用多线程处理读取操作。</li><li>值为 yes 时，启用多线程读取；no 时，读取操作仍由主线程完成（默认值为 no）。</li></ul><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>io-threads-do-reads yes
</span></span></code></pre></td></tr></table></div></div></li></ol><p>线程池管理：</p><ul><li>Redis 的线程池在启动时创建，线程数量固定。</li><li>Redis 不会动态调整线程池的大小，因此需要根据工作负载合理配置线程数量。</li></ul><h3 id=io-线程同步>I/O 线程同步<a hidden class=anchor aria-hidden=true href=#io-线程同步>#</a></h3><p>Redis 的 I/O 线程同步主要体现在两个阶段：</p><ol><li>I/O 线程之间的同步（多线程并行读取/写入时的安全）。</li><li>I/O 线程和主线程的同步（确保主线程正确处理数据）。</li></ol><p>关于 I/O 线程之间的同步，Redis 采用任务分片和线程本地数据隔离的方式：</p><ul><li>任务分片：每个 I/O 线程负责一组客户端连接，客户端连接的分配由主线程完成，各线程的任务互不重叠。</li><li>线程本地缓冲区：Redis 为每个 I/O 线程分配自己的输入/输出缓冲区，线程在处理网络 I/O 时，只会操作属于自己的缓冲区，不会访问其他线程的数据。</li><li>分阶段处理：所有线程在同一个阶段完成任务，等到所有线程完成后，才进入下一阶段（如命令解析）。</li></ul><p>而 I/O 线程与主线程之间的同步是在两个节点上进行的：</p><ul><li>I/O 线程完成数据读取后，通知主线程解析和执行命令。</li><li>主线程执行完命令后，通知 I/O 线程将结果写回客户端。</li></ul><p>为此，Redis 使用了以下机制：</p><ul><li>主线程全局控制权：主线程是唯一负责命令解析和执行的线程。</li><li>分阶段锁：主线程会等待所有 I/O 线程完成当前阶段的任务（如读取或写入）后，才进入下一阶段。阶段结束的标志由主线程统一检查。</li><li>轻量级同步标志：Redis 使用轻量级的同步机制（如原子操作和状态标志）协调主线程和 I/O 线程的状态，而不是引入复杂的锁机制。</li></ul><p>Redis 在线程同步中会使用以下几种锁机制：</p><ol><li>互斥锁（Mutex）</li></ol><p>​ Redis 使用操作系统提供的互斥锁（pthread_mutex）来保护关键资源。这种锁是重量级锁，只有在不可避免的情况下才会使用。</p><ul><li>使用场景：<ul><li>保护客户端连接列表的修改。</li><li>保护任务队列的操作。</li><li>确保线程安全的统计信息更新。</li></ul></li><li>优缺点：<ul><li>优点：简单可靠，适用于临界区较少的场景。</li><li>缺点：加锁和解锁需要上下文切换，可能增加线程之间的等待时间。</li></ul></li></ul><ol start=2><li>自旋锁（Spinlock）</li></ol><p>​ Redis 更倾向于使用自旋锁（pthread_spinlock）来减少线程等待的开销。在自旋锁中，线程不会进入睡眠状态，而是不断轮询锁的状态，直到获取锁为止。</p><ul><li>使用场景：<ul><li>临界区非常小且操作耗时短的场景，例如更新统计信息或同步标志。</li><li>自旋锁适用于高并发、锁持有时间短的情况，可以避免线程切换的开销。</li></ul></li><li>优缺点：<ul><li>优点：高效，适合临界区操作非常快的场景。</li><li>缺点：如果锁被长时间持有，会浪费 CPU 资源。</li></ul></li></ul><ol start=3><li>原子操作（Atomic Operation）</li></ol><p>​ Redis 使用原子操作（例如 __sync_fetch_and_add 或 stdatomic.h 提供的接口）来同步一些简单的共享数据，例如计数器或标志位。</p><ul><li>使用场景：<ul><li>更新 I/O 线程的完成计数。</li><li>统计信息（如处理的命令数量）的更新。</li></ul></li><li>优缺点：<ul><li>优点：无需显式加锁，性能极高。</li><li>缺点：只适用于简单的原子性操作，无法保护复杂的共享资源。</li></ul></li></ul><h2 id=持久化>持久化<a hidden class=anchor aria-hidden=true href=#持久化>#</a></h2><p>（这本书中关于持久化的内容全是围绕源码讲的，对于现阶段没有帮助，所以此章内容为参考网络资料整理而来。）</p><h3 id=rdb>RDB<a hidden class=anchor aria-hidden=true href=#rdb>#</a></h3><p>RDB（Redis Database） 是通过在特定时间间隔或满足特定触发条件时，将内存中的数据集状态“快照”（Snapshot）地保存到磁盘文件（一般为 dump.rdb）中。该文件使用二进制格式，包含 Redis 数据库在某个时间点上的所有数据状态。</p><p>Redis 的 RDB 持久化通常通过两种方式触发：</p><ol><li><p>后台定时保存（自动快照）：在 <code>redis.conf</code> 中，通过配置 <code>save</code> 命令设置保存条件。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>save 900 1    # 900秒（15分钟）内如果至少有1个key被修改就触发一次RDB保存
</span></span><span class=line><span class=cl>save 300 10   # 300秒（5分钟）内如果至少有10个key被修改就触发一次RDB保存
</span></span><span class=line><span class=cl>save 60 10000 # 60秒（1分钟）内如果至少有10000个key被修改就触发一次RDB保存
</span></span></code></pre></td></tr></table></div></div><p>当满足任意一个条件时，Redis 会触发一次 RDB 快照。</p></li><li><p>手动触发：可以在客户端执行 <code>BGSAVE</code> 命令（推荐）或 <code>SAVE</code> 命令。</p><ul><li><code>BGSAVE</code> 会在后台子进程中创建一个快照，这个过程中并不会阻塞主线程的命令处理，因此对服务影响较小。</li><li><code>SAVE</code> 则是在当前进程中执行快照生成，在保存期间阻塞所有客户端请求，一般不推荐在线上环境使用。</li></ul></li></ol><p>RDB 持久化的特点</p><ul><li>优点：<ul><li>文件紧凑：RDB 文件是二进制压缩格式，体积较小，便于传输和备份。</li><li>恢复快速：RDB 文件包含某个时刻的全量数据快照，重启时直接加载就能快速恢复到该时刻的状态。</li><li>性能影响相对较小：在使用 <code>BGSAVE</code> 时，快照工作由子进程完成，主进程依旧可以响应请求，整体对服务性能影响相对可控。</li></ul></li><li>缺点：<ul><li>潜在数据丢失：因为 RDB 不是实时保存数据，而是以一定周期或条件触发，那么在上一次 RDB 之后的修改操作若 Redis 意外崩溃，这些修改将丢失。</li><li>高并发下的开销：在进行 RDB 快照时需要 fork 子进程，复制内存页，若数据量很大，可能造成一定的性能抖动。</li></ul></li></ul><h3 id=aof>AOF<a hidden class=anchor aria-hidden=true href=#aof>#</a></h3><p>AOF 模式通过记录 每一次对 Redis 数据进行修改的命令 来实现持久化。它会将 Redis 的写操作（如 <code>SET</code>、<code>HSET</code>、<code>INCR</code> 等）以文本协议的形式追加到 AOF 文件（默认 <code>appendonly.aof</code>）末尾。</p><p>AOF 的写策略可以通过 <code>appendfsync</code> 参数控制：</p><ul><li><code>appendfsync always</code>：每次有写操作都同步（fsync）到磁盘，安全性最高但性能开销最大。</li><li><code>appendfsync everysec</code>：每秒强制进行一次磁盘同步，是默认策略，也是性能和安全的较好平衡点。在极端崩溃情况下，最多丢失1秒的数据。</li><li><code>appendfsync no</code>：不主动调用 fsync 由操作系统决定磁盘刷新时间，性能最好但可能丢失更多数据。</li></ul><p>由于 AOF 通过不断追加命令记录，随着时间推移文件会越来越大。为解决文件过大的问题，Redis 提供 AOF 重写机制。当 AOF 文件达到一定大小门限（可配置），Redis 会自动触发 AOF 重写（<code>BGREWRITEAOF</code>），过程如下：</p><ol><li>Redis fork 出一个子进程。</li><li>子进程根据当前内存数据状态生成一份最精简的命令集，将这些命令写入一个新的 AOF 临时文件。</li><li>在此过程中，主进程仍在接受新写入操作，这些操作会同时被写入内存缓冲区，并在子进程完成重写后，追加到新的 AOF 文件末尾。</li><li>当子进程完成重写后，用新的 AOF 文件替换旧文件，从而实现 AOF 文件的压缩精简。</li></ol><p>通过 AOF 重写机制，可以保证 AOF 文件不会无限增长。</p><p>AOF 的特点</p><ul><li>优点：<ul><li>数据安全性高：AOF 可以在更高频率（如每秒甚至每次写入）下同步数据到磁盘，从而最大限度地减少数据丢失。</li><li>文件易读性：AOF 是文本协议格式，打开文件就能看到具体的 Redis 命令，有利于故障排查。</li></ul></li><li>缺点：<ul><li>文件可能较大：相较于 RDB，AOF 的文件会因为不断记录写操作而变得更大。不过可以通过重写来缓解。</li><li>恢复速度稍慢：在恢复数据时，Redis 需要从头按顺序执行 AOF 文件中的所有写操作命令，处理耗时可能比加载 RDB 文件长（不过通过 AOF 重写可有效缩短恢复时间）。</li></ul></li></ul><h3 id=混合持久化>混合持久化<a hidden class=anchor aria-hidden=true href=#混合持久化>#</a></h3><p>Redis 4.0 及以上版本引入了混合持久化的机制，即在进行 AOF 重写时，可以将当前内存数据的 RDB 格式和后续增量的命令相结合，从而在恢复时既能快速加载 RDB 部分，又能保证数据的完整性。Redis 5.0 开始默认开启混合持久化。</p><p>混合持久化在进行 AOF 重写时，先写入一段 RDB 格式的二进制数据（表示当前快照状态），然后在此之后附加增量的 AOF 命令部分。这样恢复数据时先读 RDB 部分（极快恢复大部分数据），然后再应用后面的 AOF 命令（补齐最新写入的数据），实现恢复性能与数据完整性间的平衡。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/redis/>Redis</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/dailydev/postgresql%E6%8C%87%E5%8D%97%E8%AE%B0%E5%BD%95/><span class=title>« Prev</span><br><span>《PostgreSQL指南》记录</span>
</a><a class=next href=http://localhost:1313/posts/dailydev/grpc%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/><span class=title>Next »</span><br><span>《gRPC与云原生应用开发》记录</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>KurongBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>