<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《深入RabbitMQ》记录 | KurongBlog</title>
<meta name=keywords content="RabbitMQ"><meta name=description content="《深入RabbitMQ》记录
RabbitMQ 基础
AMQP 协议
AMQP，即高级消息队列协议（Advanced Meesage Queuing Protocal）。它定义了一个 AMQ 应该有以下三部分：

交换器：一个接收器接收发送到 MQ 中的消息并决定把它们投递到何处；
队列：存储接收到的消息；
绑定：定义队列和交换器之间的关系。在 RabbitMQ 中，绑定或者叫绑定键即告知一个叫交换器应该将消息投递到哪些队列中。

使用 AMQ 协议与 Rabbit 进行交互
AMQP 帧类型
AMQP 规定了五种类型的帧：

协议头帧：用于连接到 RabbitMQ，仅使用一次；
方法帧：携带发送到 RabbitMQ 或从 RabbitMQ 接收到的 RPC 请求或响应；
内容头帧：包含一条消息的大小和属性；
消息体帧：包含消息的内容；
心跳帧：确保连接，一种校验机制。

将消息编组成帧
首先是方法帧、内容头帧，这两种帧比较好理解。
而消息体帧会根据消息体的大小切分成一到多个消息体帧。
要发送消息，首先发送的是方法帧，之后是内容帧，最后是若干个消息体帧。
帧结构
方法帧携带构建 RPC 请求所需的类、方法和参数。
内容头帧包含了消息的大小和其他对消息起描述作用的属性。
消息体帧可以传输很多类型的数据，可以是二进制、文本，也可以是二进制化的图片和序列化后的json、xml。
使用协议
包含下面一个基本流程：

声明交换器
声明队列
绑定队列到交换器
发布消息到 RabbitMQ
从 RabbitMQ 消费消息

消息属性详解
使用 content-type 创建显式的消息契约
在不同的语言的消费者框架中，框架可以自动的根据 content-type 类型将其反序列化为该语言中的数据结构。
使用 gzip 和 content-encoding 压缩消息大小
通过指定 content-encoding 属性可以在消息体上应用特殊的编码。"><meta name=author content="Kurong"><link rel=canonical href=http://localhost:1313/posts/dailydev/%E6%B7%B1%E5%85%A5rabbitmq%E8%AE%B0%E5%BD%95/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/dailydev/%E6%B7%B1%E5%85%A5rabbitmq%E8%AE%B0%E5%BD%95/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><meta property="og:title" content="《深入RabbitMQ》记录"><meta property="og:description" content="《深入RabbitMQ》记录
RabbitMQ 基础
AMQP 协议
AMQP，即高级消息队列协议（Advanced Meesage Queuing Protocal）。它定义了一个 AMQ 应该有以下三部分：

交换器：一个接收器接收发送到 MQ 中的消息并决定把它们投递到何处；
队列：存储接收到的消息；
绑定：定义队列和交换器之间的关系。在 RabbitMQ 中，绑定或者叫绑定键即告知一个叫交换器应该将消息投递到哪些队列中。

使用 AMQ 协议与 Rabbit 进行交互
AMQP 帧类型
AMQP 规定了五种类型的帧：

协议头帧：用于连接到 RabbitMQ，仅使用一次；
方法帧：携带发送到 RabbitMQ 或从 RabbitMQ 接收到的 RPC 请求或响应；
内容头帧：包含一条消息的大小和属性；
消息体帧：包含消息的内容；
心跳帧：确保连接，一种校验机制。

将消息编组成帧
首先是方法帧、内容头帧，这两种帧比较好理解。
而消息体帧会根据消息体的大小切分成一到多个消息体帧。
要发送消息，首先发送的是方法帧，之后是内容帧，最后是若干个消息体帧。
帧结构
方法帧携带构建 RPC 请求所需的类、方法和参数。
内容头帧包含了消息的大小和其他对消息起描述作用的属性。
消息体帧可以传输很多类型的数据，可以是二进制、文本，也可以是二进制化的图片和序列化后的json、xml。
使用协议
包含下面一个基本流程：

声明交换器
声明队列
绑定队列到交换器
发布消息到 RabbitMQ
从 RabbitMQ 消费消息

消息属性详解
使用 content-type 创建显式的消息契约
在不同的语言的消费者框架中，框架可以自动的根据 content-type 类型将其反序列化为该语言中的数据结构。
使用 gzip 和 content-encoding 压缩消息大小
通过指定 content-encoding 属性可以在消息体上应用特殊的编码。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/dailydev/%E6%B7%B1%E5%85%A5rabbitmq%E8%AE%B0%E5%BD%95/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-28T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-28T00:00:00+00:00"><meta property="og:site_name" content="KurongBlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="《深入RabbitMQ》记录"><meta name=twitter:description content="《深入RabbitMQ》记录
RabbitMQ 基础
AMQP 协议
AMQP，即高级消息队列协议（Advanced Meesage Queuing Protocal）。它定义了一个 AMQ 应该有以下三部分：

交换器：一个接收器接收发送到 MQ 中的消息并决定把它们投递到何处；
队列：存储接收到的消息；
绑定：定义队列和交换器之间的关系。在 RabbitMQ 中，绑定或者叫绑定键即告知一个叫交换器应该将消息投递到哪些队列中。

使用 AMQ 协议与 Rabbit 进行交互
AMQP 帧类型
AMQP 规定了五种类型的帧：

协议头帧：用于连接到 RabbitMQ，仅使用一次；
方法帧：携带发送到 RabbitMQ 或从 RabbitMQ 接收到的 RPC 请求或响应；
内容头帧：包含一条消息的大小和属性；
消息体帧：包含消息的内容；
心跳帧：确保连接，一种校验机制。

将消息编组成帧
首先是方法帧、内容头帧，这两种帧比较好理解。
而消息体帧会根据消息体的大小切分成一到多个消息体帧。
要发送消息，首先发送的是方法帧，之后是内容帧，最后是若干个消息体帧。
帧结构
方法帧携带构建 RPC 请求所需的类、方法和参数。
内容头帧包含了消息的大小和其他对消息起描述作用的属性。
消息体帧可以传输很多类型的数据，可以是二进制、文本，也可以是二进制化的图片和序列化后的json、xml。
使用协议
包含下面一个基本流程：

声明交换器
声明队列
绑定队列到交换器
发布消息到 RabbitMQ
从 RabbitMQ 消费消息

消息属性详解
使用 content-type 创建显式的消息契约
在不同的语言的消费者框架中，框架可以自动的根据 content-type 类型将其反序列化为该语言中的数据结构。
使用 gzip 和 content-encoding 压缩消息大小
通过指定 content-encoding 属性可以在消息体上应用特殊的编码。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"《深入RabbitMQ》记录","item":"http://localhost:1313/posts/dailydev/%E6%B7%B1%E5%85%A5rabbitmq%E8%AE%B0%E5%BD%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《深入RabbitMQ》记录","name":"《深入RabbitMQ》记录","description":"《深入RabbitMQ》记录 RabbitMQ 基础 AMQP 协议 AMQP，即高级消息队列协议（Advanced Meesage Queuing Protocal）。它定义了一个 AMQ 应该有以下三部分：\n交换器：一个接收器接收发送到 MQ 中的消息并决定把它们投递到何处； 队列：存储接收到的消息； 绑定：定义队列和交换器之间的关系。在 RabbitMQ 中，绑定或者叫绑定键即告知一个叫交换器应该将消息投递到哪些队列中。 使用 AMQ 协议与 Rabbit 进行交互 AMQP 帧类型 AMQP 规定了五种类型的帧：\n协议头帧：用于连接到 RabbitMQ，仅使用一次； 方法帧：携带发送到 RabbitMQ 或从 RabbitMQ 接收到的 RPC 请求或响应； 内容头帧：包含一条消息的大小和属性； 消息体帧：包含消息的内容； 心跳帧：确保连接，一种校验机制。 将消息编组成帧 首先是方法帧、内容头帧，这两种帧比较好理解。\n而消息体帧会根据消息体的大小切分成一到多个消息体帧。\n要发送消息，首先发送的是方法帧，之后是内容帧，最后是若干个消息体帧。\n帧结构 方法帧携带构建 RPC 请求所需的类、方法和参数。\n内容头帧包含了消息的大小和其他对消息起描述作用的属性。\n消息体帧可以传输很多类型的数据，可以是二进制、文本，也可以是二进制化的图片和序列化后的json、xml。\n使用协议 包含下面一个基本流程：\n声明交换器 声明队列 绑定队列到交换器 发布消息到 RabbitMQ 从 RabbitMQ 消费消息 消息属性详解 使用 content-type 创建显式的消息契约 在不同的语言的消费者框架中，框架可以自动的根据 content-type 类型将其反序列化为该语言中的数据结构。\n使用 gzip 和 content-encoding 压缩消息大小 通过指定 content-encoding 属性可以在消息体上应用特殊的编码。\n","keywords":["RabbitMQ"],"articleBody":"《深入RabbitMQ》记录 RabbitMQ 基础 AMQP 协议 AMQP，即高级消息队列协议（Advanced Meesage Queuing Protocal）。它定义了一个 AMQ 应该有以下三部分：\n交换器：一个接收器接收发送到 MQ 中的消息并决定把它们投递到何处； 队列：存储接收到的消息； 绑定：定义队列和交换器之间的关系。在 RabbitMQ 中，绑定或者叫绑定键即告知一个叫交换器应该将消息投递到哪些队列中。 使用 AMQ 协议与 Rabbit 进行交互 AMQP 帧类型 AMQP 规定了五种类型的帧：\n协议头帧：用于连接到 RabbitMQ，仅使用一次； 方法帧：携带发送到 RabbitMQ 或从 RabbitMQ 接收到的 RPC 请求或响应； 内容头帧：包含一条消息的大小和属性； 消息体帧：包含消息的内容； 心跳帧：确保连接，一种校验机制。 将消息编组成帧 首先是方法帧、内容头帧，这两种帧比较好理解。\n而消息体帧会根据消息体的大小切分成一到多个消息体帧。\n要发送消息，首先发送的是方法帧，之后是内容帧，最后是若干个消息体帧。\n帧结构 方法帧携带构建 RPC 请求所需的类、方法和参数。\n内容头帧包含了消息的大小和其他对消息起描述作用的属性。\n消息体帧可以传输很多类型的数据，可以是二进制、文本，也可以是二进制化的图片和序列化后的json、xml。\n使用协议 包含下面一个基本流程：\n声明交换器 声明队列 绑定队列到交换器 发布消息到 RabbitMQ 从 RabbitMQ 消费消息 消息属性详解 使用 content-type 创建显式的消息契约 在不同的语言的消费者框架中，框架可以自动的根据 content-type 类型将其反序列化为该语言中的数据结构。\n使用 gzip 和 content-encoding 压缩消息大小 通过指定 content-encoding 属性可以在消息体上应用特殊的编码。\n使用 message-id 和 correlation-id 引用消息 correlation-id 用于指定该消息是另一个消息的响应。\n创建时间 timestamp 消息自动过期 expiration 通过 delivery-mode 平衡速度和安全性 delivery-mode 可以用来指定在消息被消费前是否要持久化消息。\n使用 app-id 和 user-id 验证消息来源 在处理消息之前检查 app-id 允许应用丢弃那些来源不明或不受支持的消息。app-id 可以是应用版本、API类等等。\nuser-id 即发送消息的用户 id。\n使用 type 获取明细 可以使用 type 来描述消息的内容。\n使用 headers 自定义属性 headers 是一个键值对表，可以存储自定义的属性。\n优先级 priority 消息发布的性能权衡 消息确认机制很重要，但同时也会影响性能，有时会关掉消息确认已保证实时性； 使用 mandatory 设置，MQ 将不再接受不可路由的消息； 将发布者确认机制作为事务的轻量级替代（二者不可并存）； 使用备用交换器处理无法路由的消息； 使用事务来批量处理消息； 使用高可用队列（HA）避免节点故障 谨慎考虑消息持久化机制； 在负载程度大时，MQ 会对狂发消息的客户端使用消息回推机制，一段时间内 MQ 不会再接收该客户端的消息。 消费信息，避免拉取 对比 Basic.Get 和 Basic.Consume Basic.Get 用于查询队列中是否存有消息，不要用于“获取”消息并消费。\n要想获取信息并消费应该使用的是 Basic.Consume 。\nRabbitMQ 采用发布-订阅模式，客户端发送命令将自己注册到 RabbitMQ 中，这样才能开始获取消息。RabbitMQ 通过唯一标识的消费者标签来分辨不同消费者。\n优化消费者性能 使用 no-ack 模式； 通过服务质量（QoS）控制消费者预取； 使用事务批量获取、消费。 拒绝消息 使用 Basic.Reject 通知代理服务器无法对所投递的消息进行处理，但只能用于单个消息的拒绝。使用 Basic.Nack 拒绝多个消息。\n被拒绝的消息可以作为死信消息由死信交换器进行路由到另一个队列。\n控制队列 可以控制队列是临时的、永久的，队列还可以只允许单个消费者、自动过期、设置消息自动过期、最大队列长度等操作。\n消息路由模式 通过 direct 交换器路由消息 当需要投递的消息有一个或多个确定的目标时，direct 交换器就是适用场景。它会检查绑定时会比较字符串是否相等，此时不允许使用任何类型的模式匹配。\n使用 fanout 交换器广播消息 所有发往 fanout 交换器的消息会被投递到所有绑定到该交换器的队列中，这也意味着这些队列对应的消费者都能消费该广播的消息。\n使用 topic 交换器有选择性地路由消息 topic 交换器会将消息路由到匹配路由键的任一队列中，但是通过采用句点分隔的形式，队列可以通过基于通配符的模式匹配的方法来绑定到路由键上。通过 * 号会匹配路由键中下一个句点前的所有字符，# 号会匹配接下来的所有字符，包括句点。\ntopic 交换器时消息路由的极佳选择，它使得单一用途的消费者能够对消息进行不同的处理。\n使用 headers 交换器有选择地路由消息 headers 交换器通过消息属性中的 headers 表支持任意的路由策略。\n交换器性能对比 四种交换器性能几乎一致 😓\n","wordCount":"192","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-11-28T00:00:00Z","dateModified":"2024-11-28T00:00:00Z","author":{"@type":"Person","name":"Kurong"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/dailydev/%E6%B7%B1%E5%85%A5rabbitmq%E8%AE%B0%E5%BD%95/"},"publisher":{"@type":"Organization","name":"KurongBlog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">《深入RabbitMQ》记录</h1><div class=post-meta><span title='2024-11-28 00:00:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;Kurong&nbsp;|&nbsp;<a href=https://github.com/KurongTohsaka/KurongTohsaka.github.io/content/posts/DailyDev/%e3%80%8a%e6%b7%b1%e5%85%a5RabbitMQ%e3%80%8b%e8%ae%b0%e5%bd%95.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#rabbitmq-基础>RabbitMQ 基础</a><ul><li><a href=#amqp-协议>AMQP 协议</a></li></ul></li><li><a href=#使用-amq-协议与-rabbit-进行交互>使用 AMQ 协议与 Rabbit 进行交互</a><ul><li><a href=#amqp-帧类型>AMQP 帧类型</a></li><li><a href=#将消息编组成帧>将消息编组成帧</a></li><li><a href=#帧结构>帧结构</a></li><li><a href=#使用协议>使用协议</a></li></ul></li><li><a href=#消息属性详解>消息属性详解</a><ul><li><a href=#使用-content-type-创建显式的消息契约>使用 content-type 创建显式的消息契约</a></li><li><a href=#使用-gzip-和-content-encoding-压缩消息大小>使用 gzip 和 content-encoding 压缩消息大小</a></li><li><a href=#使用-message-id-和-correlation-id-引用消息>使用 message-id 和 correlation-id 引用消息 </a></li><li><a href=#创建时间-timestamp>创建时间 timestamp</a></li><li><a href=#消息自动过期-expiration>消息自动过期 expiration</a></li><li><a href=#通过-delivery-mode-平衡速度和安全性>通过 delivery-mode 平衡速度和安全性</a></li><li><a href=#使用-app-id-和-user-id-验证消息来源>使用 app-id 和 user-id 验证消息来源</a></li><li><a href=#使用-type-获取明细>使用 type 获取明细</a></li><li><a href=#使用-headers-自定义属性>使用 headers 自定义属性</a></li><li><a href=#优先级-priority>优先级 priority</a></li></ul></li><li><a href=#消息发布的性能权衡>消息发布的性能权衡</a></li><li><a href=#消费信息避免拉取>消费信息，避免拉取</a><ul><li><a href=#对比-basicget-和-basicconsume>对比 Basic.Get 和 Basic.Consume</a></li><li><a href=#优化消费者性能>优化消费者性能</a></li><li><a href=#拒绝消息>拒绝消息</a></li><li><a href=#控制队列>控制队列</a></li></ul></li><li><a href=#消息路由模式>消息路由模式</a><ul><li><a href=#通过-direct-交换器路由消息>通过 direct 交换器路由消息</a></li><li><a href=#使用-fanout-交换器广播消息>使用 fanout 交换器广播消息</a></li><li><a href=#使用-topic-交换器有选择性地路由消息>使用 topic 交换器有选择性地路由消息</a></li><li><a href=#使用-headers-交换器有选择地路由消息>使用 headers 交换器有选择地路由消息</a></li><li><a href=#交换器性能对比>交换器性能对比</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=深入rabbitmq记录>《深入RabbitMQ》记录<a hidden class=anchor aria-hidden=true href=#深入rabbitmq记录>#</a></h1><h2 id=rabbitmq-基础>RabbitMQ 基础<a hidden class=anchor aria-hidden=true href=#rabbitmq-基础>#</a></h2><h3 id=amqp-协议>AMQP 协议<a hidden class=anchor aria-hidden=true href=#amqp-协议>#</a></h3><p>AMQP，即高级消息队列协议（Advanced Meesage Queuing Protocal）。它定义了一个 AMQ 应该有以下三部分：</p><ul><li>交换器：一个接收器接收发送到 MQ 中的消息并决定把它们投递到何处；</li><li>队列：存储接收到的消息；</li><li>绑定：定义队列和交换器之间的关系。在 RabbitMQ 中，绑定或者叫绑定键即告知一个叫交换器应该将消息投递到哪些队列中。</li></ul><h2 id=使用-amq-协议与-rabbit-进行交互>使用 AMQ 协议与 Rabbit 进行交互<a hidden class=anchor aria-hidden=true href=#使用-amq-协议与-rabbit-进行交互>#</a></h2><h3 id=amqp-帧类型>AMQP 帧类型<a hidden class=anchor aria-hidden=true href=#amqp-帧类型>#</a></h3><p>AMQP 规定了五种类型的帧：</p><ul><li>协议头帧：用于连接到 RabbitMQ，仅使用一次；</li><li>方法帧：携带发送到 RabbitMQ 或从 RabbitMQ 接收到的 RPC 请求或响应；</li><li>内容头帧：包含一条消息的大小和属性；</li><li>消息体帧：包含消息的内容；</li><li>心跳帧：确保连接，一种校验机制。</li></ul><h3 id=将消息编组成帧>将消息编组成帧<a hidden class=anchor aria-hidden=true href=#将消息编组成帧>#</a></h3><p>首先是方法帧、内容头帧，这两种帧比较好理解。</p><p>而消息体帧会根据消息体的大小切分成一到多个消息体帧。</p><p>要发送消息，首先发送的是方法帧，之后是内容帧，最后是若干个消息体帧。</p><h3 id=帧结构>帧结构<a hidden class=anchor aria-hidden=true href=#帧结构>#</a></h3><p>方法帧携带构建 RPC 请求所需的类、方法和参数。</p><p>内容头帧包含了消息的大小和其他对消息起描述作用的属性。</p><p>消息体帧可以传输很多类型的数据，可以是二进制、文本，也可以是二进制化的图片和序列化后的json、xml。</p><h3 id=使用协议>使用协议<a hidden class=anchor aria-hidden=true href=#使用协议>#</a></h3><p>包含下面一个基本流程：</p><ul><li>声明交换器</li><li>声明队列</li><li>绑定队列到交换器</li><li>发布消息到 RabbitMQ</li><li>从 RabbitMQ 消费消息</li></ul><h2 id=消息属性详解>消息属性详解<a hidden class=anchor aria-hidden=true href=#消息属性详解>#</a></h2><h3 id=使用-content-type-创建显式的消息契约>使用 content-type 创建显式的消息契约<a hidden class=anchor aria-hidden=true href=#使用-content-type-创建显式的消息契约>#</a></h3><p>在不同的语言的消费者框架中，框架可以自动的根据 content-type 类型将其反序列化为该语言中的数据结构。</p><h3 id=使用-gzip-和-content-encoding-压缩消息大小>使用 gzip 和 content-encoding 压缩消息大小<a hidden class=anchor aria-hidden=true href=#使用-gzip-和-content-encoding-压缩消息大小>#</a></h3><p>通过指定 content-encoding 属性可以在消息体上应用特殊的编码。</p><h3 id=使用-message-id-和-correlation-id-引用消息>使用 message-id 和 correlation-id 引用消息 <a hidden class=anchor aria-hidden=true href=#使用-message-id-和-correlation-id-引用消息>#</a></h3><p>correlation-id 用于指定该消息是另一个消息的响应。</p><h3 id=创建时间-timestamp>创建时间 timestamp<a hidden class=anchor aria-hidden=true href=#创建时间-timestamp>#</a></h3><h3 id=消息自动过期-expiration>消息自动过期 expiration<a hidden class=anchor aria-hidden=true href=#消息自动过期-expiration>#</a></h3><h3 id=通过-delivery-mode-平衡速度和安全性>通过 delivery-mode 平衡速度和安全性<a hidden class=anchor aria-hidden=true href=#通过-delivery-mode-平衡速度和安全性>#</a></h3><p>delivery-mode 可以用来指定在消息被消费前是否要持久化消息。</p><h3 id=使用-app-id-和-user-id-验证消息来源>使用 app-id 和 user-id 验证消息来源<a hidden class=anchor aria-hidden=true href=#使用-app-id-和-user-id-验证消息来源>#</a></h3><p>在处理消息之前检查 app-id 允许应用丢弃那些来源不明或不受支持的消息。app-id 可以是应用版本、API类等等。</p><p>user-id 即发送消息的用户 id。</p><h3 id=使用-type-获取明细>使用 type 获取明细<a hidden class=anchor aria-hidden=true href=#使用-type-获取明细>#</a></h3><p>可以使用 type 来描述消息的内容。</p><h3 id=使用-headers-自定义属性>使用 headers 自定义属性<a hidden class=anchor aria-hidden=true href=#使用-headers-自定义属性>#</a></h3><p>headers 是一个键值对表，可以存储自定义的属性。</p><h3 id=优先级-priority>优先级 priority<a hidden class=anchor aria-hidden=true href=#优先级-priority>#</a></h3><h2 id=消息发布的性能权衡>消息发布的性能权衡<a hidden class=anchor aria-hidden=true href=#消息发布的性能权衡>#</a></h2><ul><li>消息确认机制很重要，但同时也会影响性能，有时会关掉消息确认已保证实时性；</li><li>使用 mandatory 设置，MQ 将不再接受不可路由的消息；</li><li>将发布者确认机制作为事务的轻量级替代（二者不可并存）；</li><li>使用备用交换器处理无法路由的消息；</li><li>使用事务来批量处理消息；</li><li>使用高可用队列（HA）避免节点故障</li><li>谨慎考虑消息持久化机制；</li><li>在负载程度大时，MQ 会对狂发消息的客户端使用消息回推机制，一段时间内 MQ 不会再接收该客户端的消息。</li></ul><h2 id=消费信息避免拉取>消费信息，避免拉取<a hidden class=anchor aria-hidden=true href=#消费信息避免拉取>#</a></h2><h3 id=对比-basicget-和-basicconsume>对比 Basic.Get 和 Basic.Consume<a hidden class=anchor aria-hidden=true href=#对比-basicget-和-basicconsume>#</a></h3><p>Basic.Get 用于查询队列中是否存有消息，不要用于“获取”消息并消费。</p><p>要想获取信息并消费应该使用的是 Basic.Consume 。</p><p>RabbitMQ 采用发布-订阅模式，客户端发送命令将自己注册到 RabbitMQ 中，这样才能开始获取消息。RabbitMQ 通过唯一标识的消费者标签来分辨不同消费者。</p><h3 id=优化消费者性能>优化消费者性能<a hidden class=anchor aria-hidden=true href=#优化消费者性能>#</a></h3><ul><li>使用 no-ack 模式；</li><li>通过服务质量（QoS）控制消费者预取；</li><li>使用事务批量获取、消费。</li></ul><h3 id=拒绝消息>拒绝消息<a hidden class=anchor aria-hidden=true href=#拒绝消息>#</a></h3><p>使用 Basic.Reject 通知代理服务器无法对所投递的消息进行处理，但只能用于单个消息的拒绝。使用 Basic.Nack 拒绝多个消息。</p><p>被拒绝的消息可以作为死信消息由死信交换器进行路由到另一个队列。</p><h3 id=控制队列>控制队列<a hidden class=anchor aria-hidden=true href=#控制队列>#</a></h3><p>可以控制队列是临时的、永久的，队列还可以只允许单个消费者、自动过期、设置消息自动过期、最大队列长度等操作。</p><h2 id=消息路由模式>消息路由模式<a hidden class=anchor aria-hidden=true href=#消息路由模式>#</a></h2><h3 id=通过-direct-交换器路由消息>通过 direct 交换器路由消息<a hidden class=anchor aria-hidden=true href=#通过-direct-交换器路由消息>#</a></h3><p>当需要投递的消息有一个或多个确定的目标时，direct 交换器就是适用场景。它会检查绑定时会比较字符串是否相等，此时不允许使用任何类型的模式匹配。</p><h3 id=使用-fanout-交换器广播消息>使用 fanout 交换器广播消息<a hidden class=anchor aria-hidden=true href=#使用-fanout-交换器广播消息>#</a></h3><p>所有发往 fanout 交换器的消息会被投递到所有绑定到该交换器的队列中，这也意味着这些队列对应的消费者都能消费该广播的消息。</p><h3 id=使用-topic-交换器有选择性地路由消息>使用 topic 交换器有选择性地路由消息<a hidden class=anchor aria-hidden=true href=#使用-topic-交换器有选择性地路由消息>#</a></h3><p>topic 交换器会将消息路由到匹配路由键的任一队列中，但是通过采用句点分隔的形式，队列可以通过基于通配符的模式匹配的方法来绑定到路由键上。通过 * 号会匹配路由键中下一个句点前的所有字符，# 号会匹配接下来的所有字符，包括句点。</p><p>topic 交换器时消息路由的极佳选择，它使得单一用途的消费者能够对消息进行不同的处理。</p><h3 id=使用-headers-交换器有选择地路由消息>使用 headers 交换器有选择地路由消息<a hidden class=anchor aria-hidden=true href=#使用-headers-交换器有选择地路由消息>#</a></h3><p>headers 交换器通过消息属性中的 headers 表支持任意的路由策略。</p><h3 id=交换器性能对比>交换器性能对比<a hidden class=anchor aria-hidden=true href=#交换器性能对比>#</a></h3><p>四种交换器性能几乎一致 😓</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/rabbitmq/>RabbitMQ</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/dailydev/grpc%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/><span class=title>« Prev</span><br><span>《gRPC与云原生应用开发》记录</span>
</a><a class=next href=http://localhost:1313/posts/dailydev/%E5%8D%8E%E4%B8%BA%E4%BA%91%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91/><span class=title>Next »</span><br><span>华为云部署踩坑</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>KurongBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>