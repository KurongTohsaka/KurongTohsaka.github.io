<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction》笔记 | KurongBlog</title>
<meta name=keywords content="PaperNotes,RE,NER,EMNLP"><meta name=description content="Link
[2109.12008v1] Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction (arxiv.org)
Accepted at EMNLP 2021
Intro
信息抽取（Information Extraction, IE）旨在将文本中表达的信息转换为预定义的结构化知识格式。这个总体目标被分解为更容易自动执行和评估的子任务。因此，命名实体识别（Named Entity Recognition, NER）和关系抽取（Relation Extraction, RE）是两个关键的 IE 任务。传统上，这些任务是通过流水线方式执行的。也可以采用联合方式处理，以建模它们的相互依赖性，减少错误传播并获得更现实的评估设置。
随着 NLP 领域的总体趋势，最近在实体和关系抽取基准测试中报告的定量改进至少部分归因于使用了越来越大的预训练语言模型（Language Models, LMs），如 BERT 来获得上下文词表示。同时，人们意识到需要新的评估协议，以更好地理解所获得的神经网络模型的优缺点，而不仅仅是对一个保留测试集上的单一整体指标。
特别是，对未见数据的泛化是评估深度神经网络的关键因素。在涉及提取提及的IE任务中，这一点尤为重要：小范围的词语可能会同时出现在评估和训练数据集中。已证明这种词汇重叠与NER中神经网络的性能相关。对于流水线 RE，神经模型过度依赖候选参数的类型或其上下文中存在的特定触发词。
在端到端关系抽取中，我们可以预期这些 NER 和 RE 会结合在一起。在这项工作中，我们认为当前的评估基准不仅衡量了从文本中提取信息的能力，还衡量了模型在训练期间简单保留标记的（头、谓词、尾）三元组的能力。当模型在训练期间看到的句子上进行评估时，很难区分这两种行为中的哪一种占主导地位。
然而，我们可以假设模型可以简单地检索先前看到的信息，像一个被压缩的知识库一样，通过相关查询进行探测。因此，在包含过多已见三元组的示例上进行测试可能会高估模型的泛化能力。
即使没有标记数据，LMs也能够学习一些单词之间的关系，可以通过填空句子进行探测，其中一个参数被掩盖。
Datasets and Models
数据集选用了 CoNLL04、ACE05、SciERC。
模型选用了三个模型：

PURE：Pipeline 模型
SpERT：Joint 模型
Two are better than one（TABTO）：Joint 模型

Partitioning by Lexical Overlap（基于词汇重叠的划分）
我们根据与训练集的词汇重叠情况对测试集中的实体提及进行划分。我们区分了已见和未见的提及，并将这种划分扩展到关系上。
我们实现了一个简单的保留启发式方法（Retention Heuristic，启发式方法），将训练集中确切存在的实体提及或关系标记为其多数标签。我们在表1中报告了 NER 和 RE 的 Micro-avg. 精度、召回率和 F1 分数。"><meta name=author content="Kurong"><link rel=canonical href=http://localhost:1313/posts/papernotes/separating_retention_from_extraction/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/papernotes/separating_retention_from_extraction/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><meta property="og:title" content="《Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction》笔记"><meta property="og:description" content="Link
[2109.12008v1] Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction (arxiv.org)
Accepted at EMNLP 2021
Intro
信息抽取（Information Extraction, IE）旨在将文本中表达的信息转换为预定义的结构化知识格式。这个总体目标被分解为更容易自动执行和评估的子任务。因此，命名实体识别（Named Entity Recognition, NER）和关系抽取（Relation Extraction, RE）是两个关键的 IE 任务。传统上，这些任务是通过流水线方式执行的。也可以采用联合方式处理，以建模它们的相互依赖性，减少错误传播并获得更现实的评估设置。
随着 NLP 领域的总体趋势，最近在实体和关系抽取基准测试中报告的定量改进至少部分归因于使用了越来越大的预训练语言模型（Language Models, LMs），如 BERT 来获得上下文词表示。同时，人们意识到需要新的评估协议，以更好地理解所获得的神经网络模型的优缺点，而不仅仅是对一个保留测试集上的单一整体指标。
特别是，对未见数据的泛化是评估深度神经网络的关键因素。在涉及提取提及的IE任务中，这一点尤为重要：小范围的词语可能会同时出现在评估和训练数据集中。已证明这种词汇重叠与NER中神经网络的性能相关。对于流水线 RE，神经模型过度依赖候选参数的类型或其上下文中存在的特定触发词。
在端到端关系抽取中，我们可以预期这些 NER 和 RE 会结合在一起。在这项工作中，我们认为当前的评估基准不仅衡量了从文本中提取信息的能力，还衡量了模型在训练期间简单保留标记的（头、谓词、尾）三元组的能力。当模型在训练期间看到的句子上进行评估时，很难区分这两种行为中的哪一种占主导地位。
然而，我们可以假设模型可以简单地检索先前看到的信息，像一个被压缩的知识库一样，通过相关查询进行探测。因此，在包含过多已见三元组的示例上进行测试可能会高估模型的泛化能力。
即使没有标记数据，LMs也能够学习一些单词之间的关系，可以通过填空句子进行探测，其中一个参数被掩盖。
Datasets and Models
数据集选用了 CoNLL04、ACE05、SciERC。
模型选用了三个模型：

PURE：Pipeline 模型
SpERT：Joint 模型
Two are better than one（TABTO）：Joint 模型

Partitioning by Lexical Overlap（基于词汇重叠的划分）
我们根据与训练集的词汇重叠情况对测试集中的实体提及进行划分。我们区分了已见和未见的提及，并将这种划分扩展到关系上。
我们实现了一个简单的保留启发式方法（Retention Heuristic，启发式方法），将训练集中确切存在的实体提及或关系标记为其多数标签。我们在表1中报告了 NER 和 RE 的 Micro-avg. 精度、召回率和 F1 分数。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/papernotes/separating_retention_from_extraction/"><meta property="og:image" content="http://localhost:1313/cover/Separating_Retention_from_Extraction.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-27T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-27T00:00:00+00:00"><meta property="og:site_name" content="KurongBlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/cover/Separating_Retention_from_Extraction.png"><meta name=twitter:title content="《Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction》笔记"><meta name=twitter:description content="Link
[2109.12008v1] Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction (arxiv.org)
Accepted at EMNLP 2021
Intro
信息抽取（Information Extraction, IE）旨在将文本中表达的信息转换为预定义的结构化知识格式。这个总体目标被分解为更容易自动执行和评估的子任务。因此，命名实体识别（Named Entity Recognition, NER）和关系抽取（Relation Extraction, RE）是两个关键的 IE 任务。传统上，这些任务是通过流水线方式执行的。也可以采用联合方式处理，以建模它们的相互依赖性，减少错误传播并获得更现实的评估设置。
随着 NLP 领域的总体趋势，最近在实体和关系抽取基准测试中报告的定量改进至少部分归因于使用了越来越大的预训练语言模型（Language Models, LMs），如 BERT 来获得上下文词表示。同时，人们意识到需要新的评估协议，以更好地理解所获得的神经网络模型的优缺点，而不仅仅是对一个保留测试集上的单一整体指标。
特别是，对未见数据的泛化是评估深度神经网络的关键因素。在涉及提取提及的IE任务中，这一点尤为重要：小范围的词语可能会同时出现在评估和训练数据集中。已证明这种词汇重叠与NER中神经网络的性能相关。对于流水线 RE，神经模型过度依赖候选参数的类型或其上下文中存在的特定触发词。
在端到端关系抽取中，我们可以预期这些 NER 和 RE 会结合在一起。在这项工作中，我们认为当前的评估基准不仅衡量了从文本中提取信息的能力，还衡量了模型在训练期间简单保留标记的（头、谓词、尾）三元组的能力。当模型在训练期间看到的句子上进行评估时，很难区分这两种行为中的哪一种占主导地位。
然而，我们可以假设模型可以简单地检索先前看到的信息，像一个被压缩的知识库一样，通过相关查询进行探测。因此，在包含过多已见三元组的示例上进行测试可能会高估模型的泛化能力。
即使没有标记数据，LMs也能够学习一些单词之间的关系，可以通过填空句子进行探测，其中一个参数被掩盖。
Datasets and Models
数据集选用了 CoNLL04、ACE05、SciERC。
模型选用了三个模型：

PURE：Pipeline 模型
SpERT：Joint 模型
Two are better than one（TABTO）：Joint 模型

Partitioning by Lexical Overlap（基于词汇重叠的划分）
我们根据与训练集的词汇重叠情况对测试集中的实体提及进行划分。我们区分了已见和未见的提及，并将这种划分扩展到关系上。
我们实现了一个简单的保留启发式方法（Retention Heuristic，启发式方法），将训练集中确切存在的实体提及或关系标记为其多数标签。我们在表1中报告了 NER 和 RE 的 Micro-avg. 精度、召回率和 F1 分数。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"《Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction》笔记","item":"http://localhost:1313/posts/papernotes/separating_retention_from_extraction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction》笔记","name":"《Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction》笔记","description":"Link [2109.12008v1] Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction (arxiv.org)\nAccepted at EMNLP 2021\nIntro 信息抽取（Information Extraction, IE）旨在将文本中表达的信息转换为预定义的结构化知识格式。这个总体目标被分解为更容易自动执行和评估的子任务。因此，命名实体识别（Named Entity Recognition, NER）和关系抽取（Relation Extraction, RE）是两个关键的 IE 任务。传统上，这些任务是通过流水线方式执行的。也可以采用联合方式处理，以建模它们的相互依赖性，减少错误传播并获得更现实的评估设置。\n随着 NLP 领域的总体趋势，最近在实体和关系抽取基准测试中报告的定量改进至少部分归因于使用了越来越大的预训练语言模型（Language Models, LMs），如 BERT 来获得上下文词表示。同时，人们意识到需要新的评估协议，以更好地理解所获得的神经网络模型的优缺点，而不仅仅是对一个保留测试集上的单一整体指标。\n特别是，对未见数据的泛化是评估深度神经网络的关键因素。在涉及提取提及的IE任务中，这一点尤为重要：小范围的词语可能会同时出现在评估和训练数据集中。已证明这种词汇重叠与NER中神经网络的性能相关。对于流水线 RE，神经模型过度依赖候选参数的类型或其上下文中存在的特定触发词。\n在端到端关系抽取中，我们可以预期这些 NER 和 RE 会结合在一起。在这项工作中，我们认为当前的评估基准不仅衡量了从文本中提取信息的能力，还衡量了模型在训练期间简单保留标记的（头、谓词、尾）三元组的能力。当模型在训练期间看到的句子上进行评估时，很难区分这两种行为中的哪一种占主导地位。\n然而，我们可以假设模型可以简单地检索先前看到的信息，像一个被压缩的知识库一样，通过相关查询进行探测。因此，在包含过多已见三元组的示例上进行测试可能会高估模型的泛化能力。\n即使没有标记数据，LMs也能够学习一些单词之间的关系，可以通过填空句子进行探测，其中一个参数被掩盖。\nDatasets and Models 数据集选用了 CoNLL04、ACE05、SciERC。\n模型选用了三个模型：\nPURE：Pipeline 模型 SpERT：Joint 模型 Two are better than one（TABTO）：Joint 模型 Partitioning by Lexical Overlap（基于词汇重叠的划分） 我们根据与训练集的词汇重叠情况对测试集中的实体提及进行划分。我们区分了已见和未见的提及，并将这种划分扩展到关系上。\n我们实现了一个简单的保留启发式方法（Retention Heuristic，启发式方法），将训练集中确切存在的实体提及或关系标记为其多数标签。我们在表1中报告了 NER 和 RE 的 Micro-avg. 精度、召回率和 F1 分数。\n","keywords":["PaperNotes","RE","NER","EMNLP"],"articleBody":"Link [2109.12008v1] Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction (arxiv.org)\nAccepted at EMNLP 2021\nIntro 信息抽取（Information Extraction, IE）旨在将文本中表达的信息转换为预定义的结构化知识格式。这个总体目标被分解为更容易自动执行和评估的子任务。因此，命名实体识别（Named Entity Recognition, NER）和关系抽取（Relation Extraction, RE）是两个关键的 IE 任务。传统上，这些任务是通过流水线方式执行的。也可以采用联合方式处理，以建模它们的相互依赖性，减少错误传播并获得更现实的评估设置。\n随着 NLP 领域的总体趋势，最近在实体和关系抽取基准测试中报告的定量改进至少部分归因于使用了越来越大的预训练语言模型（Language Models, LMs），如 BERT 来获得上下文词表示。同时，人们意识到需要新的评估协议，以更好地理解所获得的神经网络模型的优缺点，而不仅仅是对一个保留测试集上的单一整体指标。\n特别是，对未见数据的泛化是评估深度神经网络的关键因素。在涉及提取提及的IE任务中，这一点尤为重要：小范围的词语可能会同时出现在评估和训练数据集中。已证明这种词汇重叠与NER中神经网络的性能相关。对于流水线 RE，神经模型过度依赖候选参数的类型或其上下文中存在的特定触发词。\n在端到端关系抽取中，我们可以预期这些 NER 和 RE 会结合在一起。在这项工作中，我们认为当前的评估基准不仅衡量了从文本中提取信息的能力，还衡量了模型在训练期间简单保留标记的（头、谓词、尾）三元组的能力。当模型在训练期间看到的句子上进行评估时，很难区分这两种行为中的哪一种占主导地位。\n然而，我们可以假设模型可以简单地检索先前看到的信息，像一个被压缩的知识库一样，通过相关查询进行探测。因此，在包含过多已见三元组的示例上进行测试可能会高估模型的泛化能力。\n即使没有标记数据，LMs也能够学习一些单词之间的关系，可以通过填空句子进行探测，其中一个参数被掩盖。\nDatasets and Models 数据集选用了 CoNLL04、ACE05、SciERC。\n模型选用了三个模型：\nPURE：Pipeline 模型 SpERT：Joint 模型 Two are better than one（TABTO）：Joint 模型 Partitioning by Lexical Overlap（基于词汇重叠的划分） 我们根据与训练集的词汇重叠情况对测试集中的实体提及进行划分。我们区分了已见和未见的提及，并将这种划分扩展到关系上。\n我们实现了一个简单的保留启发式方法（Retention Heuristic，启发式方法），将训练集中确切存在的实体提及或关系标记为其多数标签。我们在表1中报告了 NER 和 RE 的 Micro-avg. 精度、召回率和 F1 分数。\n如果一个实体提及的边界和类型都被正确预测，则认为该实体提及是正确的。对于 RE，我们在边界和严格设置中报告分数（。在边界设置中，如果关系的类型正确且其参数的边界正确，则认为关系是正确的，而不考虑其类型的检测。严格设置增加了参数实体类型也必须正确的要求。\n虽然我们无法在 SciERC 数据集上评估 TABTO，因为它不适合提取嵌套实体，但我们可以注意到每个数据集上的模型层次不同，这表明至少在当前的评估设置中，没有一种通用的最佳模型。\n最明显的比较是 SpERT 和 Ent-SpERT 之间的比较，其中上下文的显式表示被删除。这导致在关系抽取（RE）部分的性能下降，特别是在部分匹配或新关系上，因为这些实体表示对在训练中未见过。Ent-SpERT 在 CoNLL04 数据集上的精确匹配特别有效，表明其保留能力。\n其他比较则更为困难，因为每个模型的结构以及训练过程存在诸多差异。然而，PURE 管道设置似乎仅在 ACE05 上更有效，因为其命名实体识别（NER）性能显著更好，可能是因为学习了单独的 NER 和 RE 编码器，从而能够为每个独特任务学习和捕获更多特定信息。即便如此，TABTO 在边界性能上表现更好，仅在严格设置中因实体类型混淆而受到惩罚。相反，在 CoNLL04 上，TABTO 显著优于其对手，特别是在未见过的关系上。这表明它在这种情况下更有效地结合了上下文信息，其中关系和参数类型是双射映射的。\n在 SciERC 上，所有模型的性能在 RE 步骤之前的 NER 级别上已经受到影响，这使得模型性能之间的进一步区分更加困难。\nSwapping Relation Heads and Tails 为了验证模型预测中保留作为启发式方法的使用，我们选择在同类型实体之间发生的不对称关系，并在输入中交换头和尾。如果模型预测出原始三元组，那么它过度依赖于保留启发式方法，而找到交换后的三元组则证明了更广泛的上下文整合。我们在表2中展示了一个例子。\n由于实验的要求，我们必须限制在 CoNLL04 数据集中两个关系：“Kill”（杀死）在人物之间和“Located in”（位于）在地点之间。实际上，CoNLL04 是唯一一个关系类型和其参数类型之间存在双射映射的数据集，并且一致的专有名词使得交换在语法上大多是正确的。对于每种关系类型，我们只考虑包含一个对应关系实例的句子，并交换其参数。我们只考虑表3中报告的RE分数中的这种关系。我们使用严格的RE分数以及 revRE 分数来衡量句子中未表达的反向关系的提取。\n对于每种关系，模型的层次结构与整体 CoNLL04 相对应。交换参数对 NER 的影响有限，主要是对“Located in”关系。然而，这导致每个模型的 RE 下降，并且 revRE 分数表明 SpERT 和 TABTO 更频繁地预测反向关系，而不是新表达的关系。这是端到端模型保留启发式方法的另一个证明，尽管这也可能归因于语言模型。特别是对于“Located in”关系，交换后的头和尾并不完全等价，因为前者主要是城市，后者是国家。\n相反，PURE 模型不太容易保留信息，如其 revRE 分数显著小于交换句子的标准 RE 分数所示。因此，它在交换句子上优于 SpERT 和 TABTO，尽管在原始数据集上效果最差。结果的重要差异可以通过这些模型使用的不同类型的表示来解释。流水线方法允许在关系分类器中使用参数类型表示，而大多数端到端模型使用共享的实体表示中的词汇特征用于 NER 和 RE。\n","wordCount":"149","inLanguage":"en","image":"http://localhost:1313/cover/Separating_Retention_from_Extraction.png","datePublished":"2024-09-27T00:00:00Z","dateModified":"2024-09-27T00:00:00Z","author":{"@type":"Person","name":"Kurong"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/papernotes/separating_retention_from_extraction/"},"publisher":{"@type":"Organization","name":"KurongBlog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">《Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction》笔记</h1><div class=post-meta><span title='2024-09-27 00:00:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;Kurong&nbsp;|&nbsp;<a href=https://github.com/KurongTohsaka/KurongTohsaka.github.io/content/posts/PaperNotes/Separating_Retention_from_Extraction.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/cover/Separating_Retention_from_Extraction.png alt><p></p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#link>Link</a></li><li><a href=#intro>Intro</a></li><li><a href=#datasets-and-models>Datasets and Models</a></li><li><a href=#partitioning-by-lexical-overlap基于词汇重叠的划分>Partitioning by Lexical Overlap（基于词汇重叠的划分）</a></li><li><a href=#swapping-relation-heads-and-tails>Swapping Relation Heads and Tails</a></li></ul></nav></div></details></div><div class=post-content><h2 id=link>Link<a hidden class=anchor aria-hidden=true href=#link>#</a></h2><p>[<a href=https://arxiv.org/abs/2109.12008v1>2109.12008v1] Separating Retention from Extraction in the Evaluation of End-to-end Relation Extraction (arxiv.org)</a></p><p>Accepted at EMNLP 2021</p><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>信息抽取（Information Extraction, IE）旨在将文本中表达的信息转换为预定义的结构化知识格式。这个总体目标被分解为更容易自动执行和评估的子任务。因此，命名实体识别（Named Entity Recognition, NER）和关系抽取（Relation Extraction, RE）是两个关键的 IE 任务。传统上，这些任务是通过流水线方式执行的。也可以采用联合方式处理，以建模它们的相互依赖性，减少错误传播并获得更现实的评估设置。</p><p>随着 NLP 领域的总体趋势，最近在实体和关系抽取基准测试中报告的定量改进至少部分归因于使用了越来越大的预训练语言模型（Language Models, LMs），如 BERT 来获得上下文词表示。同时，人们意识到需要新的评估协议，以更好地理解所获得的神经网络模型的优缺点，而不仅仅是对一个保留测试集上的单一整体指标。</p><p>特别是，对未见数据的泛化是评估深度神经网络的关键因素。在涉及提取提及的IE任务中，这一点尤为重要：小范围的词语可能会同时出现在评估和训练数据集中。已证明这种词汇重叠与NER中神经网络的性能相关。对于流水线 RE，神经模型过度依赖候选参数的类型或其上下文中存在的特定触发词。</p><p>在端到端关系抽取中，我们可以预期这些 NER 和 RE 会结合在一起。在这项工作中，我们认为当前的评估基准不仅衡量了从文本中提取信息的能力，还衡量了模型在训练期间简单保留标记的（头、谓词、尾）三元组的能力。当模型在训练期间看到的句子上进行评估时，很难区分这两种行为中的哪一种占主导地位。</p><p>然而，我们可以假设模型可以简单地检索先前看到的信息，像一个被压缩的知识库一样，通过相关查询进行探测。因此，在包含过多已见三元组的示例上进行测试可能会高估模型的泛化能力。</p><p>即使没有标记数据，LMs也能够学习一些单词之间的关系，可以通过填空句子进行探测，其中一个参数被掩盖。</p><h2 id=datasets-and-models>Datasets and Models<a hidden class=anchor aria-hidden=true href=#datasets-and-models>#</a></h2><p>数据集选用了 CoNLL04、ACE05、SciERC。</p><p>模型选用了三个模型：</p><ul><li>PURE：Pipeline 模型</li><li>SpERT：Joint 模型</li><li>Two are better than one（TABTO）：Joint 模型</li></ul><h2 id=partitioning-by-lexical-overlap基于词汇重叠的划分>Partitioning by Lexical Overlap（基于词汇重叠的划分）<a hidden class=anchor aria-hidden=true href=#partitioning-by-lexical-overlap基于词汇重叠的划分>#</a></h2><p>我们根据与训练集的词汇重叠情况对测试集中的实体提及进行划分。我们区分了已见和未见的提及，并将这种划分扩展到关系上。</p><p>我们实现了一个简单的保留启发式方法（Retention Heuristic，启发式方法），将训练集中确切存在的实体提及或关系标记为其多数标签。我们在表1中报告了 NER 和 RE 的 Micro-avg. 精度、召回率和 F1 分数。</p><p>如果一个实体提及的边界和类型都被正确预测，则认为该实体提及是正确的。对于 RE，我们在边界和严格设置中报告分数（。在边界设置中，如果关系的类型正确且其参数的边界正确，则认为关系是正确的，而不考虑其类型的检测。严格设置增加了参数实体类型也必须正确的要求。</p><p><img loading=lazy src=/img/PaperNotes/Separating_Retention_from_Extraction/img1.png alt></p><p>虽然我们无法在 SciERC 数据集上评估 TABTO，因为它不适合提取嵌套实体，但我们可以注意到每个数据集上的模型层次不同，这表明至少在当前的评估设置中，没有一种通用的最佳模型。</p><p>最明显的比较是 SpERT 和 Ent-SpERT 之间的比较，其中上下文的显式表示被删除。这导致在关系抽取（RE）部分的性能下降，特别是在部分匹配或新关系上，因为这些实体表示对在训练中未见过。Ent-SpERT 在 CoNLL04 数据集上的精确匹配特别有效，表明其保留能力。</p><p>其他比较则更为困难，因为每个模型的结构以及训练过程存在诸多差异。然而，PURE 管道设置似乎仅在 ACE05 上更有效，因为其命名实体识别（NER）性能显著更好，可能是因为学习了单独的 NER 和 RE 编码器，从而能够为每个独特任务学习和捕获更多特定信息。即便如此，TABTO 在边界性能上表现更好，仅在严格设置中因实体类型混淆而受到惩罚。相反，在 CoNLL04 上，TABTO 显著优于其对手，特别是在未见过的关系上。这表明它在这种情况下更有效地结合了上下文信息，其中关系和参数类型是双射映射的。</p><p>在 SciERC 上，所有模型的性能在 RE 步骤之前的 NER 级别上已经受到影响，这使得模型性能之间的进一步区分更加困难。</p><h2 id=swapping-relation-heads-and-tails>Swapping Relation Heads and Tails<a hidden class=anchor aria-hidden=true href=#swapping-relation-heads-and-tails>#</a></h2><p>为了验证模型预测中保留作为启发式方法的使用，我们选择在同类型实体之间发生的不对称关系，并在输入中交换头和尾。如果模型预测出原始三元组，那么它过度依赖于保留启发式方法，而找到交换后的三元组则证明了更广泛的上下文整合。我们在表2中展示了一个例子。</p><p><img loading=lazy src=/img/PaperNotes/Separating_Retention_from_Extraction/img2.png alt></p><p>由于实验的要求，我们必须限制在 CoNLL04 数据集中两个关系：“Kill”（杀死）在人物之间和“Located in”（位于）在地点之间。实际上，CoNLL04 是唯一一个关系类型和其参数类型之间存在双射映射的数据集，并且一致的专有名词使得交换在语法上大多是正确的。对于每种关系类型，我们只考虑包含一个对应关系实例的句子，并交换其参数。我们只考虑表3中报告的RE分数中的这种关系。我们使用严格的RE分数以及 revRE 分数来衡量句子中未表达的反向关系的提取。</p><p>对于每种关系，模型的层次结构与整体 CoNLL04 相对应。交换参数对 NER 的影响有限，主要是对“Located in”关系。然而，这导致每个模型的 RE 下降，并且 revRE 分数表明 SpERT 和 TABTO 更频繁地预测反向关系，而不是新表达的关系。这是端到端模型保留启发式方法的另一个证明，尽管这也可能归因于语言模型。特别是对于“Located in”关系，交换后的头和尾并不完全等价，因为前者主要是城市，后者是国家。</p><p>相反，PURE 模型不太容易保留信息，如其 revRE 分数显著小于交换句子的标准 RE 分数所示。因此，它在交换句子上优于 SpERT 和 TABTO，尽管在原始数据集上效果最差。结果的重要差异可以通过这些模型使用的不同类型的表示来解释。流水线方法允许在关系分类器中使用参数类型表示，而大多数端到端模型使用共享的实体表示中的词汇特征用于 NER 和 RE。</p><p><img loading=lazy src=/img/PaperNotes/Separating_Retention_from_Extraction/img3.png alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/papernotes/>PaperNotes</a></li><li><a href=http://localhost:1313/tags/re/>RE</a></li><li><a href=http://localhost:1313/tags/ner/>NER</a></li><li><a href=http://localhost:1313/tags/emnlp/>EMNLP</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/papernotes/modular_self-supervision_for_document-level_relation_extraction/><span class=title>« Prev</span><br><span>《Modular Self-Supervision for Document-Level Relation Extraction》笔记</span>
</a><a class=next href=http://localhost:1313/posts/papernotes/better_few-shot_relation_extraction_with_label_prompt_dropout/><span class=title>Next »</span><br><span>《Better Few-Shot Relation Extraction with Label Prompt Dropout》笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>KurongBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>